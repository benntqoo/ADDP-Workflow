
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">claude-proxy/cmd/proxy/main.go (0.0%)</option>
				
				<option value="file1">claude-proxy/internal/ollama/client.go (64.4%)</option>
				
				<option value="file2">claude-proxy/internal/template/manager.go (87.0%)</option>
				
				<option value="file3">claude-proxy/internal/template/types.go (0.0%)</option>
				
				<option value="file4">claude-proxy/internal/terminal/manager.go (77.2%)</option>
				
				<option value="file5">claude-proxy/internal/terminal/platform.go (55.9%)</option>
				
				<option value="file6">claude-proxy/internal/terminal/types.go (100.0%)</option>
				
				<option value="file7">claude-proxy/internal/tui/model.go (61.1%)</option>
				
				<option value="file8">claude-proxy/internal/tui/styles.go (1.4%)</option>
				
				<option value="file9">claude-proxy/internal/tui/types.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "claude-proxy",
        Short: "AI Terminal Proxy - 統一所有 AI CLI 工具的終端界面",
        Long: `AI Terminal Proxy 是一個智能終端代理，提供：
• 統一的 GUI 界面管理多個 AI 終端
• Ollama 本地查詢優化，節省 30-50% token
• 1-4 數字鍵快速在不同 AI 工具間切換
• 支援 Claude Code、Gemini CLI、Cursor、Aider`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("🤖 AI Terminal Proxy v1.0")
                fmt.Println("啟動 TUI 界面...")
                // TODO: 啟動 Bubble Tea TUI 界面
        }</span>,
}

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "顯示版本信息",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("claude-proxy v1.0.0")
                fmt.Println("基於雙軌架構：Golang 終端代理 + Python MCP 工具")
        }</span>,
}

var listCmd = &amp;cobra.Command{
        Use:   "list-terminals",
        Short: "列出可用的終端類型",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("可用終端類型：")
                fmt.Println("  1. claude     - Claude Code CLI")
                fmt.Println("  2. gemini     - Gemini CLI")
                fmt.Println("  3. cursor     - Cursor CLI")
                fmt.Println("  4. aider      - Aider CLI")
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(listCmd)
}</span>

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package ollama

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
)

// NewOllamaClient 創建新的 Ollama 客戶端
func NewOllamaClient(baseURL string) *OllamaClient <span class="cov8" title="1">{
        return &amp;OllamaClient{
                BaseURL: baseURL,
                HTTPClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                Model: "qwen2.5:14b", // 默認模型
        }
}</span>

// IsHealthy 檢查 Ollama 服務是否健康
func (c *OllamaClient) IsHealthy(ctx context.Context) bool <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+"/api/tags", nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK</span>
}

// OptimizeQuery 使用 Ollama 優化查詢
func (c *OllamaClient) OptimizeQuery(ctx context.Context, query, queryContext string) (*OptimizationResult, error) <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" </span><span class="cov8" title="1">{
                return &amp;OptimizationResult{}, fmt.Errorf("query cannot be empty")
        }</span>

        <span class="cov8" title="1">startTime := time.Now()

        // 構建優化提示詞
        prompt := c.buildOptimizationPrompt(query, queryContext)

        // 發送生成請求
        generateResp, err := c.sendGenerateRequest(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;OptimizationResult{}, err
        }</span>

        <span class="cov0" title="0">processingTime := time.Since(startTime)

        // 計算估算的 token 數量
        tokensUsed := c.calculateTokens(generateResp.Response)

        return &amp;OptimizationResult{
                OriginalQuery:   query,
                OptimizedQuery:  strings.TrimSpace(generateResp.Response),
                Model:          generateResp.Model,
                ProcessingTime: processingTime,
                TokensUsed:     tokensUsed,
                Confidence:     0.8, // 固定信心度，實際實現中可能會更復雜
        }, nil</span>
}

// GetAvailableModels 獲取可用模型列表
func (c *OllamaClient) GetAvailableModels(ctx context.Context) ([]ModelInfo, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+"/api/tags", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ollama returned status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov8" title="1">var listResp ListModelsResponse
        if err := json.Unmarshal(body, &amp;listResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // 標記所有模型為可用
        <span class="cov8" title="1">for i := range listResp.Models </span><span class="cov0" title="0">{
                listResp.Models[i].Available = true
        }</span>

        <span class="cov8" title="1">return listResp.Models, nil</span>
}

// ValidateModel 驗證模型是否可用
func (c *OllamaClient) ValidateModel(ctx context.Context, modelName string) bool <span class="cov8" title="1">{
        if strings.TrimSpace(modelName) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">models, err := c.GetAvailableModels(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, model := range models </span><span class="cov0" title="0">{
                if model.Name == modelName </span><span class="cov0" title="0">{
                        return model.Available
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// SetModel 設置默認模型
func (c *OllamaClient) SetModel(model string) <span class="cov0" title="0">{
        c.Model = model
}</span>

// GetModel 獲取當前默認模型
func (c *OllamaClient) GetModel() string <span class="cov0" title="0">{
        return c.Model
}</span>

// buildOptimizationPrompt 構建查詢優化提示詞
func (c *OllamaClient) buildOptimizationPrompt(query, queryContext string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`請優化以下查詢，讓它更清晰、具體和有效：

原始查詢: %s
上下文: %s

請提供優化後的查詢，只返回優化後的查詢內容，不要包含其他解釋文字。`, query, queryContext)
}</span>

// calculateTokens 估算 token 數量
func (c *OllamaClient) calculateTokens(text string) int <span class="cov0" title="0">{
        // 簡單估算：中文字符按 1 個 token，英文字符按 1/4 個 token
        tokens := 0
        for _, r := range text </span><span class="cov0" title="0">{
                if r &gt; 127 </span><span class="cov0" title="0">{ // 非 ASCII 字符（主要是中文）
                        tokens++
                }</span> else<span class="cov0" title="0"> {
                        tokens += 1 // 英文字符計為 0.25 token，但至少 1
                }</span>
        }
        <span class="cov0" title="0">return tokens / 4</span> // 平均化處理
}

// sendGenerateRequest 發送生成請求的通用方法
func (c *OllamaClient) sendGenerateRequest(ctx context.Context, prompt string) (*GenerateResponse, error) <span class="cov8" title="1">{
        generateReq := GenerateRequest{
                Model:  c.Model,
                Prompt: prompt,
                Stream: false,
        }

        reqBody, err := json.Marshal(generateReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+"/api/generate", bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ollama returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var generateResp GenerateResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;generateResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;generateResp, nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package template

import (
        "fmt"
        "regexp"
        "strings"
        "text/template"
        "time"
)

// NewTemplateManager 創建新的模板管理器
func NewTemplateManager() *TemplateManager <span class="cov8" title="1">{
        manager := &amp;TemplateManager{
                templates:     make(map[string]*QueryTemplate),
                templateCache: make(map[string]*template.Template),
                stats:         make(map[string]*TemplateStats),
                config: &amp;TemplateConfig{
                        EnableStats:    true,
                        MaxCustom:     50,
                        CacheSize:     100,
                        ValidateStrict: false,
                },
        }

        // 初始化內建模板
        manager.initBuiltInTemplates()

        return manager
}</span>

// GetAvailableTemplates 獲取所有可用模板
func (tm *TemplateManager) GetAvailableTemplates() []*QueryTemplate <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        templates := make([]*QueryTemplate, 0, len(tm.templates))
        for _, tmpl := range tm.templates </span><span class="cov8" title="1">{
                templates = append(templates, tmpl)
        }</span>

        <span class="cov8" title="1">return templates</span>
}

// GetTemplate 根據 ID 獲取模板
func (tm *TemplateManager) GetTemplate(templateID string) (*QueryTemplate, bool) <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        template, exists := tm.templates[templateID]
        return template, exists
}</span>

// ApplyTemplate 應用模板到用戶查詢
func (tm *TemplateManager) ApplyTemplate(templateID, userQuery string, context map[string]string) (*ApplyResult, error) <span class="cov8" title="1">{
        if strings.TrimSpace(userQuery) == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user query cannot be empty")
        }</span>

        <span class="cov8" title="1">template, exists := tm.GetTemplate(templateID)
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("template not found: %s", templateID)
        }</span>

        // 準備模板數據
        <span class="cov8" title="1">data := make(map[string]string)
        data["query"] = userQuery

        // 添加用戶提供的上下文
        if context != nil </span><span class="cov8" title="1">{
                for key, value := range context </span><span class="cov8" title="1">{
                        data[key] = value
                }</span>
        }

        // 渲染模板
        <span class="cov8" title="1">optimizedPrompt, err := tm.renderTemplate(template.Prompt, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to render template: %w", err)
        }</span>

        // 計算 token 估算
        <span class="cov8" title="1">tokensEstimate := tm.estimateTokens(optimizedPrompt)

        // 更新統計
        tm.updateStats(templateID, tokensEstimate)

        return &amp;ApplyResult{
                TemplateID:      templateID,
                OriginalQuery:   userQuery,
                OptimizedPrompt: optimizedPrompt,
                Context:         context,
                AppliedAt:       time.Now(),
                TokensEstimate:  tokensEstimate,
        }, nil</span>
}

// GetTemplatesByCategory 根據分類獲取模板
func (tm *TemplateManager) GetTemplatesByCategory(category string) []*QueryTemplate <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        var templates []*QueryTemplate
        for _, tmpl := range tm.templates </span><span class="cov8" title="1">{
                if tmpl.Category == category </span><span class="cov8" title="1">{
                        templates = append(templates, tmpl)
                }</span>
        }

        <span class="cov8" title="1">return templates</span>
}

// ValidateTemplate 驗證模板
func (tm *TemplateManager) ValidateTemplate(tmpl *QueryTemplate) bool <span class="cov8" title="1">{
        if tmpl == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 檢查必需字段
        <span class="cov8" title="1">if strings.TrimSpace(tmpl.ID) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(tmpl.Prompt) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // 驗證模板語法
        <span class="cov8" title="1">_, err := template.New("test").Parse(tmpl.Prompt)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 檢查變量一致性
        <span class="cov8" title="1">return tm.validateTemplateVariables(tmpl)</span>
}

// AddCustomTemplate 添加自定義模板
func (tm *TemplateManager) AddCustomTemplate(tmpl *QueryTemplate) error <span class="cov8" title="1">{
        if !tm.ValidateTemplate(tmpl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template")
        }</span>

        <span class="cov8" title="1">tm.mu.Lock()
        defer tm.mu.Unlock()

        // 檢查是否已存在
        if _, exists := tm.templates[tmpl.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("template already exists: %s", tmpl.ID)
        }</span>

        // 設置創建時間
        <span class="cov8" title="1">if tmpl.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                tmpl.CreatedAt = time.Now()
        }</span>
        <span class="cov8" title="1">tmpl.UpdatedAt = time.Now()
        tmpl.IsBuiltIn = false

        tm.templates[tmpl.ID] = tmpl
        return nil</span>
}

// initBuiltInTemplates 初始化內建模板
func (tm *TemplateManager) initBuiltInTemplates() <span class="cov8" title="1">{
        builtInTemplates := []*QueryTemplate{
                {
                        ID:          TemplateCoding,
                        Name:        "編碼模板",
                        Description: "用於代碼開發和實現的優化模板",
                        Category:    CategoryDevelopment,
                        Prompt: `作為一名資深{{.language}}開發者，請幫助我{{.query}}。

請考慮以下要求：
- 使用最佳實踐和編碼規範
- 提供清晰的代碼註釋
- 考慮錯誤處理和邊界情況
- 複雜度：{{.complexity}}
{{if .framework}}
- 使用框架：{{.framework}}
{{end}}

請提供詳細的實現方案和代碼示例。`,
                        Variables: []string{"query", "language", "complexity", "framework"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateDebug,
                        Name:        "調試模板",
                        Description: "用於問題診斷和錯誤修復的優化模板",
                        Category:    CategoryMaintenance,
                        Prompt: `作為調試專家，請幫助我分析和解決以下問題：

問題描述：{{.query}}

相關信息：
- 程式語言：{{.language}}
- 錯誤類型：{{.error_type}}
{{if .stack_trace}}
- 堆疊追蹤：{{.stack_trace}}
{{end}}

請提供：
1. 問題根因分析
2. 具體的解決方案
3. 預防措施建議`,
                        Variables: []string{"query", "language", "error_type", "stack_trace"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateRefactor,
                        Name:        "重構模板",
                        Description: "用於代碼重構和優化的模板",
                        Category:    CategoryMaintenance,
                        Prompt: `作為代碼重構專家，請幫助我{{.query}}。

重構目標：
- 提高代碼可讀性和可維護性
- 優化性能
- 遵循 SOLID 原則
- 改善代碼結構

{{if .focus_area}}
重點關注：{{.focus_area}}
{{end}}

請提供重構前後的對比和詳細的改進建議。`,
                        Variables: []string{"query", "focus_area"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateDocumentation,
                        Name:        "文檔模板",
                        Description: "用於生成和改進文檔的模板",
                        Category:    CategoryDevelopment,
                        Prompt: `作為技術文檔專家，請幫助我{{.query}}。

文檔要求：
- 清晰簡潔的語言
- 結構化的內容組織
- 包含實際使用示例
- 面向{{.target_audience}}

{{if .doc_type}}
文檔類型：{{.doc_type}}
{{end}}

請確保文檔易於理解和實用。`,
                        Variables: []string{"query", "target_audience", "doc_type"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateTesting,
                        Name:        "測試模板",
                        Description: "用於編寫和改進測試的模板",
                        Category:    CategoryDevelopment,
                        Prompt: `作為測試專家，請幫助我{{.query}}。

測試要求：
- 完整的測試覆蓋
- 包含正面和負面測試案例
- 使用適當的測試框架
- 清晰的測試意圖

{{if .test_type}}
測試類型：{{.test_type}}
{{end}}
{{if .coverage_target}}
覆蓋率目標：{{.coverage_target}}
{{end}}

請提供詳細的測試策略和實現代碼。`,
                        Variables: []string{"query", "test_type", "coverage_target"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplatePerformance,
                        Name:        "性能優化模板",
                        Description: "用於性能分析和優化的模板",
                        Category:    CategoryAnalysis,
                        Prompt: `作為性能優化專家，請幫助我{{.query}}。

性能分析重點：
- 識別性能瓶頸
- 提供具體的優化方案
- 考慮內存和 CPU 使用
- 提供性能測試建議

{{if .performance_metric}}
關注指標：{{.performance_metric}}
{{end}}
{{if .current_performance}}
當前性能：{{.current_performance}}
{{end}}

請提供詳細的分析和優化建議。`,
                        Variables: []string{"query", "performance_metric", "current_performance"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
        }

        for _, tmpl := range builtInTemplates </span><span class="cov8" title="1">{
                tm.templates[tmpl.ID] = tmpl
        }</span>
}

// renderTemplate 渲染模板
func (tm *TemplateManager) renderTemplate(promptTemplate string, data map[string]string) (string, error) <span class="cov8" title="1">{
        // 計算模板哈希作為緩存鍵
        cacheKey := tm.getTemplateHash(promptTemplate)

        // 嘗試從緩存獲取
        tm.mu.RLock()
        cachedTemplate, exists := tm.templateCache[cacheKey]
        tm.mu.RUnlock()

        var tmpl *template.Template
        var err error

        if exists </span><span class="cov0" title="0">{
                tmpl = cachedTemplate
        }</span> else<span class="cov8" title="1"> {
                // 編譯新模板
                tmpl, err = template.New("prompt").Parse(promptTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // 添加到緩存
                <span class="cov8" title="1">tm.mu.Lock()
                if len(tm.templateCache) &lt; tm.config.CacheSize </span><span class="cov8" title="1">{
                        tm.templateCache[cacheKey] = tmpl
                }</span>
                <span class="cov8" title="1">tm.mu.Unlock()</span>
        }

        <span class="cov8" title="1">var result strings.Builder
        if err := tmpl.Execute(&amp;result, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return result.String(), nil</span>
}

// validateTemplateVariables 驗證模板變量
func (tm *TemplateManager) validateTemplateVariables(tmpl *QueryTemplate) bool <span class="cov8" title="1">{
        // 從模板中提取變量
        re := regexp.MustCompile(`\{\{\.(\w+)\}\}`)
        matches := re.FindAllStringSubmatch(tmpl.Prompt, -1)

        templateVars := make(map[string]bool)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        templateVars[match[1]] = true
                }</span>
        }

        // 檢查聲明的變量是否都在模板中使用
        <span class="cov8" title="1">declaredVars := make(map[string]bool)
        for _, variable := range tmpl.Variables </span><span class="cov8" title="1">{
                declaredVars[variable] = true
        }</span>

        // 模板中的變量都應該在聲明列表中
        <span class="cov8" title="1">for variable := range templateVars </span><span class="cov8" title="1">{
                if !declaredVars[variable] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// estimateTokens 估算 token 數量
func (tm *TemplateManager) estimateTokens(text string) int <span class="cov8" title="1">{
        // 簡單估算：中文字符 1 token，英文字符 0.25 token
        tokens := 0
        for _, r := range text </span><span class="cov8" title="1">{
                if r &gt; 127 </span><span class="cov8" title="1">{ // 非 ASCII 字符（主要是中文）
                        tokens++
                }</span> else<span class="cov8" title="1"> {
                        tokens += 1 // 英文字符
                }</span>
        }
        <span class="cov8" title="1">return tokens / 3</span> // 平均化處理
}

// getTemplateHash 生成模板哈希值（簡單實現）
func (tm *TemplateManager) getTemplateHash(template string) string <span class="cov8" title="1">{
        // 簡單的哈希實現：使用字符串長度和前後字符
        length := len(template)
        if length == 0 </span><span class="cov0" title="0">{
                return "empty"
        }</span>

        <span class="cov8" title="1">first := template[0]
        last := template[length-1]

        return fmt.Sprintf("%d_%c_%c", length, first, last)</span>
}

// updateStats 更新模板使用統計
func (tm *TemplateManager) updateStats(templateID string, tokens int) <span class="cov8" title="1">{
        if !tm.config.EnableStats </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tm.mu.Lock()
        defer tm.mu.Unlock()

        stats, exists := tm.stats[templateID]
        if !exists </span><span class="cov8" title="1">{
                stats = &amp;TemplateStats{
                        TemplateID: templateID,
                }
                tm.stats[templateID] = stats
        }</span>

        <span class="cov8" title="1">stats.UsageCount++
        stats.LastUsed = time.Now()

        // 更新平均 token 數
        if stats.UsageCount == 1 </span><span class="cov8" title="1">{
                stats.AvgTokens = float64(tokens)
        }</span> else<span class="cov0" title="0"> {
                stats.AvgTokens = (stats.AvgTokens*float64(stats.UsageCount-1) + float64(tokens)) / float64(stats.UsageCount)
        }</span>

        // 假設所有應用都成功（實際實現中可能需要追蹤失敗）
        <span class="cov8" title="1">stats.SuccessRate = 1.0</span>
}

// GetStats 獲取模板使用統計
func (tm *TemplateManager) GetStats(templateID string) (*TemplateStats, bool) <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        stats, exists := tm.stats[templateID]
        return stats, exists
}</pre>
		
		<pre class="file" id="file3" style="display: none">package template

import (
        "sync"
        "text/template"
        "time"
)

// 預定義模板 ID
const (
        TemplateCoding        = "coding"
        TemplateDebug         = "debug"
        TemplateRefactor      = "refactor"
        TemplateDocumentation = "documentation"
        TemplateTesting       = "testing"
        TemplatePerformance   = "performance"
)

// 模板分類
const (
        CategoryDevelopment = "development"
        CategoryMaintenance = "maintenance"
        CategoryAnalysis    = "analysis"
)

// QueryTemplate 查詢優化模板
type QueryTemplate struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description"`
        Category    string            `json:"category"`
        Prompt      string            `json:"prompt"`       // 模板提示詞，支持變量替換
        Variables   []string          `json:"variables"`    // 模板中的變量列表
        Metadata    map[string]string `json:"metadata"`     // 額外的元數據
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        IsBuiltIn   bool              `json:"is_built_in"`  // 是否為內建模板
}

// ApplyResult 模板應用結果
type ApplyResult struct {
        TemplateID      string            `json:"template_id"`
        OriginalQuery   string            `json:"original_query"`
        OptimizedPrompt string            `json:"optimized_prompt"`
        Context         map[string]string `json:"context"`
        AppliedAt       time.Time         `json:"applied_at"`
        TokensEstimate  int               `json:"tokens_estimate"`
}

// TemplateManager 模板管理器
type TemplateManager struct {
        templates    map[string]*QueryTemplate
        templateCache map[string]*template.Template // 已編譯的模板緩存
        stats        map[string]*TemplateStats     // 使用統計
        config       *TemplateConfig               // 配置
        mu           sync.RWMutex
}

// TemplateStats 模板使用統計
type TemplateStats struct {
        TemplateID  string    `json:"template_id"`
        UsageCount  int       `json:"usage_count"`
        LastUsed    time.Time `json:"last_used"`
        AvgTokens   float64   `json:"avg_tokens"`
        SuccessRate float64   `json:"success_rate"`
}

// TemplateConfig 模板配置
type TemplateConfig struct {
        EnableStats     bool `json:"enable_stats"`
        MaxCustom       int  `json:"max_custom"`        // 最大自定義模板數量
        CacheSize       int  `json:"cache_size"`        // 緩存大小
        ValidateStrict  bool `json:"validate_strict"`   // 嚴格驗證模式
}

// VariableInfo 變量信息
type VariableInfo struct {
        Name        string `json:"name"`
        Type        string `json:"type"`
        Required    bool   `json:"required"`
        Default     string `json:"default"`
        Description string `json:"description"`
}

// TemplateValidationError 模板驗證錯誤
type TemplateValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

func (e *TemplateValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</pre>
		
		<pre class="file" id="file4" style="display: none">package terminal

import (
        "bufio"
        "context"
        "fmt"
        "os/exec"
        "sync"
        "time"
)

// TerminalManager 實現 Manager 接口
type TerminalManager struct {
        terminals map[string]*Terminal
        mu        sync.RWMutex
        healthy   bool
}

// NewTerminalManager 創建一個新的終端管理器
func NewTerminalManager() *TerminalManager <span class="cov8" title="1">{
        return &amp;TerminalManager{
                terminals: make(map[string]*Terminal),
                healthy:   true,
        }
}</span>

// StartTerminal 啟動指定的終端
func (tm *TerminalManager) StartTerminal(config TerminalConfig) error <span class="cov8" title="1">{
        return tm.StartTerminalWithContext(context.Background(), config)
}</span>

// StartTerminalWithContext 使用上下文啟動指定的終端
func (tm *TerminalManager) StartTerminalWithContext(ctx context.Context, config TerminalConfig) error <span class="cov8" title="1">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        // 檢查終端是否已存在
        if _, exists := tm.terminals[config.Name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' already exists", config.Name)
        }</span>

        // 創建新的終端實例
        <span class="cov8" title="1">terminal := &amp;Terminal{
                Name:     config.Name,
                Type:     config.Type,
                Status:   StatusStarting,
                LastUsed: time.Now().Unix(),
        }

        // 創建命令
        cmd := tm.createCommand(config)
        if cmd == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create command for terminal type %s", config.Type.String())
        }</span>

        <span class="cov8" title="1">terminal.Process = cmd

        // 設置輸入輸出管道
        if err := tm.setupPipes(terminal); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup pipes: %w", err)
        }</span>

        // 在後台啟動進程
        <span class="cov8" title="1">if err := tm.startProcess(ctx, terminal); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start process: %w", err)
        }</span>

        // 添加到管理器
        <span class="cov8" title="1">tm.terminals[config.Name] = terminal
        terminal.SetStatus(StatusRunning)

        return nil</span>
}

// StopTerminal 停止指定名稱的終端
func (tm *TerminalManager) StopTerminal(name string) error <span class="cov8" title="1">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        terminal, exists := tm.terminals[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' not found", name)
        }</span>

        // 設置停止狀態
        <span class="cov8" title="1">terminal.SetStatus(StatusStopping)

        // 停止進程
        if terminal.Process != nil &amp;&amp; terminal.Process.Process != nil </span><span class="cov8" title="1">{
                if err := terminal.Process.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        terminal.SetStatus(StatusError)
                        return fmt.Errorf("failed to kill process: %w", err)
                }</span>
        }

        // 等待進程結束
        <span class="cov8" title="1">if terminal.Process != nil </span><span class="cov8" title="1">{
                _ = terminal.Process.Wait()
        }</span>

        <span class="cov8" title="1">terminal.SetStatus(StatusStopped)
        return nil</span>
}

// SendCommand 向指定終端發送命令
func (tm *TerminalManager) SendCommand(name string, command string) error <span class="cov8" title="1">{
        tm.mu.RLock()
        terminal, exists := tm.terminals[name]
        tm.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' not found", name)
        }</span>

        <span class="cov8" title="1">if !terminal.IsRunning() </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' is not running", name)
        }</span>

        // 更新最後使用時間
        <span class="cov8" title="1">terminal.mu.Lock()
        terminal.LastUsed = time.Now().Unix()
        terminal.mu.Unlock()

        // 發送命令
        if terminal.Stdin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("terminal '%s' stdin not available", name)
        }</span>

        <span class="cov8" title="1">if _, err := terminal.Stdin.WriteString(command + "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write command: %w", err)
        }</span>

        <span class="cov8" title="1">if err := terminal.Stdin.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush command: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetTerminal 獲取指定名稱的終端
func (tm *TerminalManager) GetTerminal(name string) (*Terminal, bool) <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        terminal, exists := tm.terminals[name]
        return terminal, exists
}</span>

// ListTerminals 列出所有終端
func (tm *TerminalManager) ListTerminals() []*Terminal <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        terminals := make([]*Terminal, 0, len(tm.terminals))
        for _, terminal := range tm.terminals </span><span class="cov8" title="1">{
                terminals = append(terminals, terminal)
        }</span>

        <span class="cov8" title="1">return terminals</span>
}

// IsHealthy 檢查終端管理器是否健康
func (tm *TerminalManager) IsHealthy() bool <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        return tm.healthy
}</span>

// createCommand 創建對應類型的命令
func (tm *TerminalManager) createCommand(config TerminalConfig) *exec.Cmd <span class="cov8" title="1">{
        var cmd *exec.Cmd

        switch config.Type </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                cmd = exec.Command("claude")</span>
        case TypeGeminiCLI:<span class="cov0" title="0">
                cmd = exec.Command("gemini")</span>
        case TypeCursor:<span class="cov0" title="0">
                cmd = exec.Command("cursor", "--cli")</span>
        case TypeAider:<span class="cov0" title="0">
                cmd = exec.Command("aider")</span>
        case TypeCustom:<span class="cov8" title="1">
                // 對於測試，使用一個簡單的命令
                cmd = exec.Command("echo", "test")</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        // 設置工作目錄
        <span class="cov8" title="1">if config.WorkingDir != "" </span><span class="cov8" title="1">{
                cmd.Dir = config.WorkingDir
        }</span>

        // 設置環境變量
        <span class="cov8" title="1">if config.Environment != nil </span><span class="cov0" title="0">{
                for key, value := range config.Environment </span><span class="cov0" title="0">{
                        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // 添加額外參數
        <span class="cov8" title="1">if config.Args != nil </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, config.Args...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// setupPipes 設置進程的輸入輸出管道
func (tm *TerminalManager) setupPipes(terminal *Terminal) error <span class="cov8" title="1">{
        // 設置標準輸入管道
        stdin, err := terminal.Process.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>
        <span class="cov8" title="1">terminal.Stdin = bufio.NewWriter(stdin)

        // 設置標準輸出管道
        stdout, err := terminal.Process.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>
        <span class="cov8" title="1">terminal.Stdout = bufio.NewScanner(stdout)

        return nil</span>
}

// startProcess 在後台啟動進程
func (tm *TerminalManager) startProcess(ctx context.Context, terminal *Terminal) error <span class="cov8" title="1">{
        // 創建一個帶取消功能的上下文
        processCtx, cancel := context.WithCancel(ctx)
        defer cancel()

        // 設置超時
        done := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                done &lt;- terminal.Process.Start()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        terminal.SetStatus(StatusError)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-processCtx.Done():<span class="cov0" title="0">
                terminal.SetStatus(StatusError)
                return processCtx.Err()</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"> // 5秒超時
                terminal.SetStatus(StatusError)
                return fmt.Errorf("timeout starting process")</span>
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package terminal

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
)

// PlatformAdapter 提供跨平台的終端管理功能
type PlatformAdapter struct {
        os string
}

// NewPlatformAdapter 創建新的平台適配器
func NewPlatformAdapter() *PlatformAdapter <span class="cov8" title="1">{
        return &amp;PlatformAdapter{
                os: runtime.GOOS,
        }
}</span>

// GetDefaultShell 獲取當前平台的默認 shell
func (pa *PlatformAdapter) GetDefaultShell() string <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 優先使用 PowerShell，備選 cmd
                if pa.ValidateCommand("powershell.exe") </span><span class="cov8" title="1">{
                        return "powershell.exe"
                }</span>
                <span class="cov0" title="0">return "cmd.exe"</span>
        case "darwin", "linux":<span class="cov0" title="0">
                // Unix-like 系統優先使用 bash，備選 sh
                if pa.ValidateCommand("/bin/bash") </span><span class="cov0" title="0">{
                        return "/bin/bash"
                }</span>
                <span class="cov0" title="0">return "/bin/sh"</span>
        default:<span class="cov0" title="0">
                // 其他系統使用通用 shell
                return "/bin/sh"</span>
        }
}

// GetExecutablePath 獲取命令的完整可執行路徑
func (pa *PlatformAdapter) GetExecutablePath(command string) string <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 系統處理
                extensions := []string{"", ".exe", ".cmd", ".bat", ".com"}

                for _, ext := range extensions </span><span class="cov8" title="1">{
                        fullCommand := command + ext
                        if path, err := exec.LookPath(fullCommand); err == nil </span><span class="cov8" title="1">{
                                return path
                        }</span>
                }

                // 如果沒找到，返回帶 .exe 的版本
                <span class="cov8" title="1">return command + ".exe"</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統
                if path, err := exec.LookPath(command); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>

                // 如果沒找到，返回原命令（可能在 PATH 中）
                <span class="cov0" title="0">return command</span>
        }
}

// CreateCommand 創建適合當前平台的命令
func (pa *PlatformAdapter) CreateCommand(config TerminalConfig) *exec.Cmd <span class="cov8" title="1">{
        var cmdPath string
        var args []string

        switch config.Type </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("claude")
                args = []string{cmdPath}</span>

        case TypeGeminiCLI:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("gemini")
                args = []string{cmdPath}</span>

        case TypeCursor:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("cursor")
                args = []string{cmdPath, "--cli"}</span>

        case TypeAider:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("aider")
                args = []string{cmdPath}</span>

        case TypeCustom:<span class="cov8" title="1">
                // 對於測試，使用平台適當的測試命令
                if pa.os == "windows" </span><span class="cov8" title="1">{
                        cmdPath = pa.GetExecutablePath("cmd")
                        args = []string{cmdPath, "/c", "echo", "test"}
                }</span> else<span class="cov0" title="0"> {
                        cmdPath = "/bin/echo"
                        args = []string{cmdPath, "test"}
                }</span>

        default:<span class="cov0" title="0">
                // 默認使用 shell
                cmdPath = pa.GetDefaultShell()
                args = []string{cmdPath}</span>
        }

        // 創建命令
        <span class="cov8" title="1">cmd := &amp;exec.Cmd{
                Path: cmdPath,
                Args: args,
        }

        // 設置工作目錄
        if config.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = config.WorkingDir
        }</span>

        // 添加額外參數
        <span class="cov8" title="1">if config.Args != nil </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, config.Args...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// SetupEnvironment 設置命令的環境變量
func (pa *PlatformAdapter) SetupEnvironment(cmd *exec.Cmd, config TerminalConfig) <span class="cov8" title="1">{
        // 獲取當前環境變量
        env := os.Environ()

        // 添加自定義環境變量
        if config.Environment != nil </span><span class="cov8" title="1">{
                for key, value := range config.Environment </span><span class="cov8" title="1">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // 添加平台特定的環境變量
        <span class="cov8" title="1">switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 特定環境設置
                env = append(env, "AI_TERMINAL_PLATFORM=windows")

                // 確保 PATH 包含必要的目錄
                pathEnvVar := pa.findPathVariable(env)
                if pathEnvVar == "" </span><span class="cov0" title="0">{
                        env = append(env, "PATH=C:\\Windows\\System32")
                }</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統特定環境設置
                env = append(env, "AI_TERMINAL_PLATFORM=unix")

                // 確保基本的 PATH
                pathEnvVar := pa.findPathVariable(env)
                if pathEnvVar == "" </span><span class="cov0" title="0">{
                        env = append(env, "PATH=/usr/local/bin:/usr/bin:/bin")
                }</span>
        }

        <span class="cov8" title="1">cmd.Env = env</span>
}

// ValidateCommand 檢查命令是否存在
func (pa *PlatformAdapter) ValidateCommand(command string) bool <span class="cov8" title="1">{
        // 如果是絕對路徑，直接檢查文件是否存在
        if filepath.IsAbs(command) </span><span class="cov0" title="0">{
                _, err := os.Stat(command)
                return err == nil
        }</span>

        // 使用 exec.LookPath 在 PATH 中查找
        <span class="cov8" title="1">_, err := exec.LookPath(command)
        return err == nil</span>
}

// GetProcessInfo 獲取進程信息
func (pa *PlatformAdapter) GetProcessInfo(pid int) *ProcessInfo <span class="cov8" title="1">{
        info := &amp;ProcessInfo{
                PID: pid,
        }

        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 使用 WMI 或 tasklist 獲取進程信息
                info.Command = pa.getWindowsProcessInfo(pid)
                info.ExecutablePath = pa.getWindowsExecutablePath(pid)
                info.Status = "running"</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統使用 /proc 或 ps
                info.Command = pa.getUnixProcessInfo(pid)
                info.CommandLine = pa.getUnixCommandLine(pid)
                info.Status = "running"</span>
        }

        <span class="cov8" title="1">return info</span>
}

// KillProcess 跨平台殺死進程
func (pa *PlatformAdapter) KillProcess(pid int) error <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 使用 taskkill
                cmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", pid))
                return cmd.Run()</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統使用 kill
                cmd := exec.Command("kill", "-TERM", fmt.Sprintf("%d", pid))
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        // 如果 TERM 失敗，嘗試 KILL
                        cmd = exec.Command("kill", "-KILL", fmt.Sprintf("%d", pid))
                        return cmd.Run()
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// 輔助方法：查找 PATH 環境變量
func (pa *PlatformAdapter) findPathVariable(env []string) string <span class="cov8" title="1">{
        for _, envVar := range env </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.ToUpper(envVar), "PATH=") </span><span class="cov8" title="1">{
                        return envVar
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Windows 特定的進程信息獲取
func (pa *PlatformAdapter) getWindowsProcessInfo(pid int) string <span class="cov8" title="1">{
        // 簡化實現：在實際項目中可能需要使用 WMI
        cmd := exec.Command("tasklist", "/FI", fmt.Sprintf("PID eq %d", pid), "/FO", "CSV", "/NH")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        // 解析 CSV 輸出獲取進程名
        <span class="cov8" title="1">lines := strings.Split(string(output), "\n")
        if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov8" title="1">{
                fields := strings.Split(lines[0], ",")
                if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                        // 移除引號
                        return strings.Trim(fields[0], "\"")
                }</span>
        }

        <span class="cov0" title="0">return "unknown"</span>
}

// Windows 獲取可執行文件路徑
func (pa *PlatformAdapter) getWindowsExecutablePath(pid int) string <span class="cov8" title="1">{
        // 簡化實現：實際項目中可能需要使用 Windows API
        return "unknown"
}</span>

// Unix 特定的進程信息獲取
func (pa *PlatformAdapter) getUnixProcessInfo(pid int) string <span class="cov0" title="0">{
        // 嘗試從 /proc/PID/comm 讀取進程名
        commPath := fmt.Sprintf("/proc/%d/comm", pid)
        if data, err := os.ReadFile(commPath); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(string(data))
        }</span>

        // 備選：使用 ps 命令
        <span class="cov0" title="0">cmd := exec.Command("ps", "-p", fmt.Sprintf("%d", pid), "-o", "comm=")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// Unix 獲取命令行
func (pa *PlatformAdapter) getUnixCommandLine(pid int) string <span class="cov0" title="0">{
        // 嘗試從 /proc/PID/cmdline 讀取命令行
        cmdlinePath := fmt.Sprintf("/proc/%d/cmdline", pid)
        if data, err := os.ReadFile(cmdlinePath); err == nil </span><span class="cov0" title="0">{
                // /proc/PID/cmdline 使用 null 字符分隔參數
                cmdline := strings.ReplaceAll(string(data), "\x00", " ")
                return strings.TrimSpace(cmdline)
        }</span>

        // 備選：使用 ps 命令
        <span class="cov0" title="0">cmd := exec.Command("ps", "-p", fmt.Sprintf("%d", pid), "-o", "args=")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// ProcessInfo 跨平台進程信息結構
type ProcessInfo struct {
        PID            int    // 進程 ID
        Command        string // 進程命令名
        CommandLine    string // 完整命令行
        ExecutablePath string // 可執行文件路徑
        Status         string // 進程狀態
}</pre>
		
		<pre class="file" id="file6" style="display: none">package terminal

import (
        "bufio"
        "os/exec"
        "sync"
)

// TerminalType 表示支援的 AI 終端類型
type TerminalType int

const (
        TypeClaudeCode TerminalType = iota // Claude Code CLI
        TypeGeminiCLI                      // Gemini CLI
        TypeCursor                         // Cursor CLI
        TypeAider                          // Aider CLI
        TypeCustom                         // 自定義終端
)

// String 返回終端類型的字符串表示
func (t TerminalType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                return "claude"</span>
        case TypeGeminiCLI:<span class="cov8" title="1">
                return "gemini"</span>
        case TypeCursor:<span class="cov8" title="1">
                return "cursor"</span>
        case TypeAider:<span class="cov8" title="1">
                return "aider"</span>
        case TypeCustom:<span class="cov8" title="1">
                return "custom"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// CommandName 返回終端類型對應的命令名
func (t TerminalType) CommandName() string <span class="cov8" title="1">{
        switch t </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                return "claude"</span>
        case TypeGeminiCLI:<span class="cov8" title="1">
                return "gemini"</span>
        case TypeCursor:<span class="cov8" title="1">
                return "cursor"</span>
        case TypeAider:<span class="cov8" title="1">
                return "aider"</span>
        default:<span class="cov8" title="1">
                return "bash"</span>
        }
}

// TerminalStatus 表示終端狀態
type TerminalStatus int

const (
        StatusStopped TerminalStatus = iota // 已停止
        StatusStarting                      // 啟動中
        StatusRunning                       // 運行中
        StatusStopping                      // 停止中
        StatusError                         // 錯誤狀態
)

// String 返回終端狀態的字符串表示
func (s TerminalStatus) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StatusStopped:<span class="cov8" title="1">
                return "stopped"</span>
        case StatusStarting:<span class="cov8" title="1">
                return "starting"</span>
        case StatusRunning:<span class="cov8" title="1">
                return "running"</span>
        case StatusStopping:<span class="cov8" title="1">
                return "stopping"</span>
        case StatusError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Terminal 表示一個 AI 終端實例
type Terminal struct {
        Name     string         // 終端名稱
        Type     TerminalType   // 終端類型
        Status   TerminalStatus // 終端狀態
        Process  *exec.Cmd      // 底層進程
        Stdin    *bufio.Writer  // 標準輸入寫入器
        Stdout   *bufio.Scanner // 標準輸出掃描器
        LastUsed int64          // 最後使用時間戳
        mu       sync.RWMutex   // 保護並發訪問的鎖
}

// GetStatus 安全地獲取終端狀態
func (t *Terminal) GetStatus() TerminalStatus <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.Status
}</span>

// SetStatus 安全地設置終端狀態
func (t *Terminal) SetStatus(status TerminalStatus) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.Status = status
}</span>

// IsRunning 檢查終端是否正在運行
func (t *Terminal) IsRunning() bool <span class="cov8" title="1">{
        return t.GetStatus() == StatusRunning
}</span>

// TerminalConfig 終端配置
type TerminalConfig struct {
        Type        TerminalType          // 終端類型
        Name        string                // 終端名稱
        WorkingDir  string                // 工作目錄
        Environment map[string]string     // 環境變量
        Args        []string              // 額外參數
}

// Manager 介面定義終端管理器的行為
type Manager interface {
        // StartTerminal 啟動指定的終端
        StartTerminal(config TerminalConfig) error

        // StopTerminal 停止指定名稱的終端
        StopTerminal(name string) error

        // SendCommand 向指定終端發送命令
        SendCommand(name string, command string) error

        // GetTerminal 獲取指定名稱的終端
        GetTerminal(name string) (*Terminal, bool)

        // ListTerminals 列出所有終端
        ListTerminals() []*Terminal

        // IsHealthy 檢查終端管理器是否健康
        IsHealthy() bool
}</pre>
		
		<pre class="file" id="file7" style="display: none">package tui

import (
        "context"
        "fmt"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "claude-proxy/internal/ollama"
        "claude-proxy/internal/template"
        "claude-proxy/internal/terminal"
)

// NewModel 創建新的 TUI 模型
func NewModel() Model <span class="cov8" title="1">{
        return Model{
                terminalManager: terminal.NewTerminalManager(),
                ollamaClient:    ollama.NewOllamaClient("http://localhost:11434"),
                templateManager: template.NewTemplateManager(),
                currentView:     ViewMain,
                status:          "準備就緒",
                lastUpdate:      time.Now(),
                terminals:       make([]TerminalInfo, 0),
                selectedIndex:   0,
                maxItems:        10,
                styles:          NewStyles(),
        }
}</span>

// Init 初始化模型
func (m Model) Init() tea.Cmd <span class="cov8" title="1">{
        return tea.Batch(
                tickCmd(),
                m.updateTerminalsCmd(),
        )
}</span>

// Update 更新模型
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                return m.handleKeyMsg(msg)</span>

        case TickMsg:<span class="cov8" title="1">
                m.lastUpdate = msg.Time
                m.updateStatus()
                return m, tickCmd()</span>

        case TerminalStatusMsg:<span class="cov8" title="1">
                m.updateTerminalStatus(msg.Name, msg.Status)
                return m, nil</span>

        case QueryResultMsg:<span class="cov0" title="0">
                m.handleQueryResult(msg)
                return m, nil</span>

        case ErrorMsg:<span class="cov0" title="0">
                m.handleError(msg.Err.Error())
                return m, nil</span>

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                return m, nil</span>

        default:<span class="cov0" title="0">
                return m, nil</span>
        }
}

// View 渲染視圖
func (m Model) View() string <span class="cov8" title="1">{
        var content strings.Builder

        // 標題
        content.WriteString(m.renderHeader())
        content.WriteString("\n\n")

        // 主內容區域
        switch m.currentView </span>{
        case ViewMain:<span class="cov8" title="1">
                content.WriteString(m.renderMainView())</span>
        case ViewTerminals:<span class="cov8" title="1">
                content.WriteString(m.renderTerminalsView())</span>
        case ViewTemplates:<span class="cov8" title="1">
                content.WriteString(m.renderTemplatesView())</span>
        case ViewSettings:<span class="cov8" title="1">
                content.WriteString(m.renderSettingsView())</span>
        }

        <span class="cov8" title="1">content.WriteString("\n\n")

        // 狀態欄
        content.WriteString(m.renderStatusBar())

        // 幫助信息
        content.WriteString("\n")
        content.WriteString(m.renderHelp())

        return content.String()</span>
}

// handleKeyMsg 處理按鍵消息
func (m Model) handleKeyMsg(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "q", "ctrl+c":<span class="cov8" title="1">
                return m, tea.Quit</span>

        case "1":<span class="cov8" title="1">
                m.switchView(ViewTerminals)
                return m, m.updateTerminalsCmd()</span>

        case "2":<span class="cov8" title="1">
                m.switchView(ViewTemplates)
                return m, nil</span>

        case "3":<span class="cov8" title="1">
                m.switchView(ViewSettings)
                return m, nil</span>

        case "up", "k":<span class="cov0" title="0">
                if m.selectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        m.selectedIndex--
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "down", "j":<span class="cov0" title="0">
                if m.selectedIndex &lt; m.maxItems-1 </span><span class="cov0" title="0">{
                        m.selectedIndex++
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "enter":<span class="cov0" title="0">
                return m.handleEnterKey()</span>

        case "esc":<span class="cov0" title="0">
                m.switchView(ViewMain)
                return m, nil</span>

        default:<span class="cov0" title="0">
                return m, nil</span>
        }
}

// handleEnterKey 處理回車鍵
func (m Model) handleEnterKey() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch m.currentView </span>{
        case ViewTerminals:<span class="cov0" title="0">
                // 在終端視圖中，回車可以啟動/停止終端
                if len(m.terminals) &gt; m.selectedIndex </span><span class="cov0" title="0">{
                        terminal := m.terminals[m.selectedIndex]
                        if terminal.Status == "stopped" </span><span class="cov0" title="0">{
                                err := m.startTerminal(terminal.Name, terminal.Type)
                                if err != nil </span><span class="cov0" title="0">{
                                        m.handleError(fmt.Sprintf("啟動終端失敗: %v", err))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                err := m.stopTerminal(terminal.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        m.handleError(fmt.Sprintf("停止終端失敗: %v", err))
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, m.updateTerminalsCmd()</span>

        case ViewTemplates:<span class="cov0" title="0">
                // 在模板視圖中，回車可以應用模板
                return m, nil</span>

        default:<span class="cov0" title="0">
                return m, nil</span>
        }
}

// switchView 切換視圖
func (m *Model) switchView(view ViewType) <span class="cov8" title="1">{
        m.currentView = view
        m.selectedIndex = 0
        m.status = fmt.Sprintf("切換到 %s", view.String())
}</span>

// renderHeader 渲染標題
func (m Model) renderHeader() string <span class="cov8" title="1">{
        return fmt.Sprintf("🤖 AI 終端代理 - %s", m.currentView.String())
}</span>

// renderMainView 渲染主視圖
func (m Model) renderMainView() string <span class="cov8" title="1">{
        var content strings.Builder

        content.WriteString("歡迎使用 AI 終端代理系統\n\n")
        content.WriteString("功能概覽:\n")
        content.WriteString("• 多終端管理 (Claude Code, Gemini CLI, Cursor, Aider)\n")
        content.WriteString("• Ollama 本地 LLM 查詢優化\n")
        content.WriteString("• 智能模板系統\n")
        content.WriteString("• 跨平台支持\n\n")

        content.WriteString("快速操作:\n")
        content.WriteString("1️⃣  終端管理  2️⃣  模板管理  3️⃣  系統設置\n")

        return content.String()
}</span>

// renderTerminalsView 渲染終端視圖
func (m Model) renderTerminalsView() string <span class="cov8" title="1">{
        var content strings.Builder

        // 標題
        content.WriteString(m.styles.TitleStyle.Render("📺 終端管理"))
        content.WriteString("\n\n")

        if len(m.terminals) == 0 </span><span class="cov8" title="1">{
                emptyMsg := m.styles.DescriptionStyle.Render("暫無活動終端")
                helpMsg := m.styles.InfoStyle.Render("使用 Enter 鍵創建新終端")
                content.WriteString(emptyMsg + "\n" + helpMsg)
                return content.String()
        }</span>

        <span class="cov0" title="0">content.WriteString(m.styles.SubtitleStyle.Render("活動終端列表:"))
        content.WriteString("\n\n")

        // 渲染終端列表
        for i, term := range m.terminals </span><span class="cov0" title="0">{
                style := m.styles.MenuItemStyle
                prefix := "  "
                if i == m.selectedIndex </span><span class="cov0" title="0">{
                        style = m.styles.SelectedItemStyle
                        prefix = "▶ "
                }</span>

                <span class="cov0" title="0">statusIcon := GetStatusIcon(term.Status)
                line := fmt.Sprintf("%s%s %s (%s) %s",
                        prefix, statusIcon, term.Name, term.Type, term.Status)

                content.WriteString(style.Render(line))
                content.WriteString("\n")</span>
        }

        <span class="cov0" title="0">content.WriteString("\n")
        content.WriteString(m.styles.HelpStyle.Render("💡 按 Enter 啟動/停止選中的終端"))

        return content.String()</span>
}

// renderTemplatesView 渲染模板視圖
func (m Model) renderTemplatesView() string <span class="cov8" title="1">{
        var content strings.Builder

        content.WriteString("📝 模板管理\n\n")

        templates := m.templateManager.GetAvailableTemplates()

        if len(templates) == 0 </span><span class="cov0" title="0">{
                content.WriteString("暫無可用模板")
                return content.String()
        }</span>

        <span class="cov8" title="1">content.WriteString("可用模板:\n\n")

        for i, tmpl := range templates </span><span class="cov8" title="1">{
                if i &gt;= m.maxItems </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">prefix := "  "
                if i == m.selectedIndex </span><span class="cov8" title="1">{
                        prefix = "▶ "
                }</span>

                <span class="cov8" title="1">categoryIcon := "📂"
                switch tmpl.Category </span>{
                case "development":<span class="cov8" title="1">
                        categoryIcon = "💻"</span>
                case "maintenance":<span class="cov8" title="1">
                        categoryIcon = "🔧"</span>
                case "analysis":<span class="cov8" title="1">
                        categoryIcon = "📊"</span>
                }

                <span class="cov8" title="1">content.WriteString(fmt.Sprintf("%s%s %s - %s\n",
                        prefix, categoryIcon, tmpl.Name, tmpl.Description))</span>
        }

        <span class="cov8" title="1">content.WriteString("\n💡 按 Enter 使用選中的模板")

        return content.String()</span>
}

// renderSettingsView 渲染設置視圖
func (m Model) renderSettingsView() string <span class="cov8" title="1">{
        var content strings.Builder

        content.WriteString("⚙️ 系統設置\n\n")

        // Ollama 連接狀態
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        ollamaHealthy := m.ollamaClient.IsHealthy(ctx)
        ollamaStatus := "🔴 離線"
        if ollamaHealthy </span><span class="cov8" title="1">{
                ollamaStatus = "🟢 在線"
        }</span>

        <span class="cov8" title="1">content.WriteString(fmt.Sprintf("Ollama 狀態: %s\n", ollamaStatus))
        content.WriteString(fmt.Sprintf("終端管理器: 🟢 就緒\n"))
        content.WriteString(fmt.Sprintf("模板系統: 🟢 已載入 %d 個模板\n",
                len(m.templateManager.GetAvailableTemplates())))

        content.WriteString("\n系統信息:\n")
        content.WriteString(fmt.Sprintf("• 運行時間: %v\n",
                time.Since(m.lastUpdate).Truncate(time.Second)))
        content.WriteString(fmt.Sprintf("• 活動終端: %d\n", len(m.terminals)))

        return content.String()</span>
}

// renderStatusBar 渲染狀態欄
func (m Model) renderStatusBar() string <span class="cov8" title="1">{
        return fmt.Sprintf("狀態: %s | 更新時間: %s",
                m.status, m.lastUpdate.Format("15:04:05"))
}</span>

// renderHelp 渲染幫助信息
func (m Model) renderHelp() string <span class="cov8" title="1">{
        return "按鍵: ↑/k ↓/j 選擇 | Enter 確認 | 1-3 切換視圖 | q/Ctrl+C 退出"
}</span>

// updateStatus 更新狀態
func (m *Model) updateStatus() <span class="cov8" title="1">{
        m.status = "系統運行中"
}</span>

// updateTerminalStatus 更新終端狀態
func (m *Model) updateTerminalStatus(name, status string) <span class="cov8" title="1">{
        for i := range m.terminals </span><span class="cov0" title="0">{
                if m.terminals[i].Name == name </span><span class="cov0" title="0">{
                        m.terminals[i].Status = status
                        break</span>
                }
        }
}

// handleQueryResult 處理查詢結果
func (m *Model) handleQueryResult(msg QueryResultMsg) <span class="cov0" title="0">{
        if msg.Success </span><span class="cov0" title="0">{
                m.status = fmt.Sprintf("查詢完成: %s", msg.TemplateID)
        }</span> else<span class="cov0" title="0"> {
                m.status = "查詢失敗"
        }</span>
}

// handleError 處理錯誤
func (m *Model) handleError(err string) <span class="cov8" title="1">{
        m.status = fmt.Sprintf("錯誤: %s", err)
}</span>

// startTerminal 啟動終端
func (m *Model) startTerminal(name, termType string) error <span class="cov8" title="1">{
        config := terminal.TerminalConfig{
                Type: m.getTerminalType(termType),
                Name: name,
        }

        return m.terminalManager.StartTerminal(config)
}</span>

// stopTerminal 停止終端
func (m *Model) stopTerminal(name string) error <span class="cov8" title="1">{
        return m.terminalManager.StopTerminal(name)
}</span>

// listTerminals 列出終端
func (m *Model) listTerminals() []TerminalInfo <span class="cov8" title="1">{
        terminals := m.terminalManager.ListTerminals()
        result := make([]TerminalInfo, len(terminals))

        for i, term := range terminals </span><span class="cov8" title="1">{
                result[i] = TerminalInfo{
                        Name:     term.Name,
                        Type:     term.Type.String(),
                        Status:   term.GetStatus().String(),
                        LastUsed: time.Unix(term.LastUsed, 0),
                }
        }</span>

        <span class="cov8" title="1">return result</span>
}

// optimizeQuery 優化查詢
func (m *Model) optimizeQuery(query, templateID string) (*template.ApplyResult, error) <span class="cov8" title="1">{
        context := make(map[string]string)
        context["language"] = "Go"
        context["complexity"] = "中等"

        return m.templateManager.ApplyTemplate(templateID, query, context)
}</span>

// getTerminalType 獲取終端類型
func (m *Model) getTerminalType(typeStr string) terminal.TerminalType <span class="cov8" title="1">{
        switch typeStr </span>{
        case "claude":<span class="cov8" title="1">
                return terminal.TypeClaudeCode</span>
        case "gemini":<span class="cov0" title="0">
                return terminal.TypeGeminiCLI</span>
        case "cursor":<span class="cov0" title="0">
                return terminal.TypeCursor</span>
        case "aider":<span class="cov0" title="0">
                return terminal.TypeAider</span>
        default:<span class="cov0" title="0">
                return terminal.TypeCustom</span>
        }
}

// updateTerminalsCmd 更新終端列表命令
func (m *Model) updateTerminalsCmd() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // 更新終端列表
                _ = m.listTerminals()

                // 創建一個模擬的終端狀態更新
                return TerminalStatusMsg{
                        Name:   "system",
                        Status: "updated",
                }
        }</span>
}

// tickCmd 創建定時器命令
func tickCmd() tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(time.Second, func(t time.Time) tea.Msg </span><span class="cov8" title="1">{
                return TickMsg{Time: t}
        }</span>)
}

// Getter 方法用於測試和集成

// GetCurrentView 獲取當前視圖
func (m Model) GetCurrentView() ViewType <span class="cov0" title="0">{
        return m.currentView
}</span>

// GetTerminalManager 獲取終端管理器
func (m Model) GetTerminalManager() *terminal.TerminalManager <span class="cov0" title="0">{
        return m.terminalManager
}</span>

// GetOllamaClient 獲取 Ollama 客戶端
func (m Model) GetOllamaClient() *ollama.OllamaClient <span class="cov0" title="0">{
        return m.ollamaClient
}</span>

// GetTemplateManager 獲取模板管理器
func (m Model) GetTemplateManager() *template.TemplateManager <span class="cov0" title="0">{
        return m.templateManager
}</span>

// SwitchView 公開的視圖切換方法
func (m *Model) SwitchView(view ViewType) <span class="cov0" title="0">{
        m.switchView(view)
}</span>

// OptimizeQuery 公開的查詢優化方法
func (m *Model) OptimizeQuery(query, templateID string) (*template.ApplyResult, error) <span class="cov0" title="0">{
        return m.optimizeQuery(query, templateID)
}</span>

// ListTerminals 公開的終端列表方法
func (m *Model) ListTerminals() []TerminalInfo <span class="cov0" title="0">{
        return m.listTerminals()
}</pre>
		
		<pre class="file" id="file8" style="display: none">package tui

import (
        "github.com/charmbracelet/lipgloss"
)

// 顏色定義
var (
        Primary   = lipgloss.Color("#007ACC")
        Secondary = lipgloss.Color("#6C7B7F")
        Success   = lipgloss.Color("#28A745")
        Warning   = lipgloss.Color("#FFC107")
        Error     = lipgloss.Color("#DC3545")
        Muted     = lipgloss.Color("#6C757D")
        Border    = lipgloss.Color("#E9ECEF")
        Highlight = lipgloss.Color("#FFF3CD")
)

// Styles TUI 樣式集合
type Styles struct {
        // 容器樣式
        AppStyle    lipgloss.Style
        HeaderStyle lipgloss.Style
        ContentStyle lipgloss.Style
        StatusStyle lipgloss.Style
        HelpStyle   lipgloss.Style

        // 組件樣式
        MenuStyle         lipgloss.Style
        MenuItemStyle     lipgloss.Style
        SelectedItemStyle lipgloss.Style
        DisabledItemStyle lipgloss.Style

        // 狀態樣式
        SuccessStyle lipgloss.Style
        WarningStyle lipgloss.Style
        ErrorStyle   lipgloss.Style
        InfoStyle    lipgloss.Style

        // 特殊樣式
        TitleStyle      lipgloss.Style
        SubtitleStyle   lipgloss.Style
        DescriptionStyle lipgloss.Style
        KeyStyle        lipgloss.Style
        ValueStyle      lipgloss.Style
}

// NewStyles 創建新的樣式集合
func NewStyles() *Styles <span class="cov8" title="1">{
        return &amp;Styles{
                // 容器樣式
                AppStyle: lipgloss.NewStyle().
                        Padding(1, 2),

                HeaderStyle: lipgloss.NewStyle().
                        Foreground(Primary).
                        Bold(true).
                        Padding(0, 1).
                        MarginBottom(1),

                ContentStyle: lipgloss.NewStyle().
                        Padding(0, 1).
                        MarginBottom(1),

                StatusStyle: lipgloss.NewStyle().
                        Foreground(Muted).
                        Padding(0, 1).
                        Border(lipgloss.NormalBorder(), true, false, false, false).
                        BorderForeground(Border),

                HelpStyle: lipgloss.NewStyle().
                        Foreground(Muted).
                        Italic(true).
                        Padding(0, 1),

                // 組件樣式
                MenuStyle: lipgloss.NewStyle().
                        Padding(0, 1),

                MenuItemStyle: lipgloss.NewStyle().
                        Padding(0, 1),

                SelectedItemStyle: lipgloss.NewStyle().
                        Foreground(Primary).
                        Bold(true).
                        Padding(0, 1).
                        Background(Highlight),

                DisabledItemStyle: lipgloss.NewStyle().
                        Foreground(Muted).
                        Padding(0, 1),

                // 狀態樣式
                SuccessStyle: lipgloss.NewStyle().
                        Foreground(Success).
                        Bold(true),

                WarningStyle: lipgloss.NewStyle().
                        Foreground(Warning).
                        Bold(true),

                ErrorStyle: lipgloss.NewStyle().
                        Foreground(Error).
                        Bold(true),

                InfoStyle: lipgloss.NewStyle().
                        Foreground(Primary),

                // 特殊樣式
                TitleStyle: lipgloss.NewStyle().
                        Foreground(Primary).
                        Bold(true).
                        Underline(true),

                SubtitleStyle: lipgloss.NewStyle().
                        Foreground(Secondary).
                        Bold(true),

                DescriptionStyle: lipgloss.NewStyle().
                        Foreground(Muted),

                KeyStyle: lipgloss.NewStyle().
                        Foreground(Primary).
                        Bold(true),

                ValueStyle: lipgloss.NewStyle().
                        Foreground(Secondary),
        }
}</span>

// RenderBox 渲染帶邊框的盒子
func (s *Styles) RenderBox(title, content string, width int) string <span class="cov0" title="0">{
        boxStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(Border).
                Padding(1).
                Width(width)

        if title != "" </span><span class="cov0" title="0">{
                titleStyle := lipgloss.NewStyle().
                        Foreground(Primary).
                        Bold(true).
                        Padding(0, 1)

                return boxStyle.Render(
                        titleStyle.Render(title) + "\n\n" + content,
                )
        }</span>

        <span class="cov0" title="0">return boxStyle.Render(content)</span>
}

// RenderList 渲染列表
func (s *Styles) RenderList(items []string, selectedIndex int) string <span class="cov0" title="0">{
        var result string

        for i, item := range items </span><span class="cov0" title="0">{
                style := s.MenuItemStyle
                prefix := "  "

                if i == selectedIndex </span><span class="cov0" title="0">{
                        style = s.SelectedItemStyle
                        prefix = "▶ "
                }</span>

                <span class="cov0" title="0">result += style.Render(prefix + item) + "\n"</span>
        }

        <span class="cov0" title="0">return result</span>
}

// RenderStatus 渲染狀態信息
func (s *Styles) RenderStatus(status, statusType string) string <span class="cov0" title="0">{
        var style lipgloss.Style

        switch statusType </span>{
        case "success":<span class="cov0" title="0">
                style = s.SuccessStyle</span>
        case "warning":<span class="cov0" title="0">
                style = s.WarningStyle</span>
        case "error":<span class="cov0" title="0">
                style = s.ErrorStyle</span>
        default:<span class="cov0" title="0">
                style = s.InfoStyle</span>
        }

        <span class="cov0" title="0">return style.Render(status)</span>
}

// RenderKeyValue 渲染鍵值對
func (s *Styles) RenderKeyValue(key, value string) string <span class="cov0" title="0">{
        return s.KeyStyle.Render(key) + ": " + s.ValueStyle.Render(value)
}</span>

// RenderProgress 渲染進度條
func (s *Styles) RenderProgress(current, total int, width int) string <span class="cov0" title="0">{
        if total == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">progress := float64(current) / float64(total)
        filledWidth := int(progress * float64(width))

        filled := lipgloss.NewStyle().
                Background(Success).
                Render(lipgloss.PlaceHorizontal(filledWidth, lipgloss.Left, ""))

        empty := lipgloss.NewStyle().
                Background(Muted).
                Render(lipgloss.PlaceHorizontal(width-filledWidth, lipgloss.Left, ""))

        return lipgloss.JoinHorizontal(lipgloss.Left, filled, empty)</span>
}

// RenderTable 渲染簡單表格
func (s *Styles) RenderTable(headers []string, rows [][]string) string <span class="cov0" title="0">{
        if len(headers) == 0 || len(rows) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // 計算列寬
        <span class="cov0" title="0">colWidths := make([]int, len(headers))
        for i, header := range headers </span><span class="cov0" title="0">{
                colWidths[i] = len(header)
        }</span>

        <span class="cov0" title="0">for _, row := range rows </span><span class="cov0" title="0">{
                for i, cell := range row </span><span class="cov0" title="0">{
                        if i &lt; len(colWidths) &amp;&amp; len(cell) &gt; colWidths[i] </span><span class="cov0" title="0">{
                                colWidths[i] = len(cell)
                        }</span>
                }
        }

        <span class="cov0" title="0">var result string

        // 渲染標題
        headerRow := ""
        for i, header := range headers </span><span class="cov0" title="0">{
                cellStyle := s.KeyStyle.Copy().
                        Width(colWidths[i]).
                        Align(lipgloss.Left)
                headerRow += cellStyle.Render(header) + " "
        }</span>
        <span class="cov0" title="0">result += headerRow + "\n"

        // 渲染分隔線
        separator := ""
        for _, width := range colWidths </span><span class="cov0" title="0">{
                separator += lipgloss.NewStyle().
                        Width(width).
                        Render(lipgloss.PlaceHorizontal(width, lipgloss.Left, "─")) + " "
        }</span>
        <span class="cov0" title="0">result += separator + "\n"

        // 渲染數據行
        for _, row := range rows </span><span class="cov0" title="0">{
                dataRow := ""
                for i, cell := range row </span><span class="cov0" title="0">{
                        if i &lt; len(colWidths) </span><span class="cov0" title="0">{
                                cellStyle := s.ValueStyle.Copy().
                                        Width(colWidths[i]).
                                        Align(lipgloss.Left)
                                dataRow += cellStyle.Render(cell) + " "
                        }</span>
                }
                <span class="cov0" title="0">result += dataRow + "\n"</span>
        }

        <span class="cov0" title="0">return result</span>
}

// GetStatusIcon 獲取狀態圖標
func GetStatusIcon(status string) string <span class="cov0" title="0">{
        switch status </span>{
        case "running":<span class="cov0" title="0">
                return "🟢"</span>
        case "starting":<span class="cov0" title="0">
                return "🟡"</span>
        case "stopping":<span class="cov0" title="0">
                return "🟠"</span>
        case "stopped":<span class="cov0" title="0">
                return "🔴"</span>
        case "error":<span class="cov0" title="0">
                return "❌"</span>
        default:<span class="cov0" title="0">
                return "⚪"</span>
        }
}

// GetCategoryIcon 獲取分類圖標
func GetCategoryIcon(category string) string <span class="cov0" title="0">{
        switch category </span>{
        case "development":<span class="cov0" title="0">
                return "💻"</span>
        case "maintenance":<span class="cov0" title="0">
                return "🔧"</span>
        case "analysis":<span class="cov0" title="0">
                return "📊"</span>
        case "testing":<span class="cov0" title="0">
                return "🧪"</span>
        case "documentation":<span class="cov0" title="0">
                return "📝"</span>
        default:<span class="cov0" title="0">
                return "📂"</span>
        }
}</pre>
		
		<pre class="file" id="file9" style="display: none">package tui

import (
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "claude-proxy/internal/ollama"
        "claude-proxy/internal/template"
        "claude-proxy/internal/terminal"
)

// ViewType 視圖類型
type ViewType int

const (
        ViewMain ViewType = iota
        ViewTerminals
        ViewTemplates
        ViewSettings
)

// String 返回視圖類型的字符串表示
func (v ViewType) String() string <span class="cov8" title="1">{
        switch v </span>{
        case ViewMain:<span class="cov8" title="1">
                return "主畫面"</span>
        case ViewTerminals:<span class="cov8" title="1">
                return "終端管理"</span>
        case ViewTemplates:<span class="cov8" title="1">
                return "模板管理"</span>
        case ViewSettings:<span class="cov8" title="1">
                return "設置"</span>
        default:<span class="cov8" title="1">
                return "未知視圖"</span>
        }
}

// Model TUI 主模型
type Model struct {
        // 核心組件
        terminalManager *terminal.TerminalManager
        ollamaClient    *ollama.OllamaClient
        templateManager *template.TemplateManager

        // UI 狀態
        currentView ViewType
        width       int
        height      int
        styles      *Styles

        // 應用狀態
        status     string
        lastUpdate time.Time
        terminals  []TerminalInfo

        // 輸入狀態
        inputMode   bool
        inputBuffer string
        inputPrompt string

        // 選擇狀態
        selectedIndex int
        maxItems      int
}

// TerminalInfo 終端信息顯示結構
type TerminalInfo struct {
        Name     string
        Type     string
        Status   string
        LastUsed time.Time
        PID      int
}

// TemplateInfo 模板信息顯示結構
type TemplateInfo struct {
        ID          string
        Name        string
        Category    string
        Description string
        UsageCount  int
}

// TickMsg 定時更新消息
type TickMsg struct {
        Time time.Time
}

// TerminalStatusMsg 終端狀態更新消息
type TerminalStatusMsg struct {
        Name   string
        Status string
}

// QueryResultMsg 查詢結果消息
type QueryResultMsg struct {
        Query      string
        Result     string
        TemplateID string
        Success    bool
}

// ErrorMsg 錯誤消息
type ErrorMsg struct {
        Err error
}

// InputCompleteMsg 輸入完成消息
type InputCompleteMsg struct {
        Input string
        Mode  string
}

// WindowSizeMsg 窗口大小變化消息
type WindowSizeMsg struct {
        Width  int
        Height int
}

// Config TUI 配置
type Config struct {
        // 外觀設置
        ShowBorder    bool `json:"show_border"`
        ShowStatus    bool `json:"show_status"`
        ShowHelp      bool `json:"show_help"`

        // 更新間隔
        UpdateInterval time.Duration `json:"update_interval"`

        // 顏色主題
        Theme string `json:"theme"`

        // 快捷鍵設置
        KeyBindings map[string]string `json:"key_bindings"`
}

// DefaultConfig 返回默認配置
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                ShowBorder:     true,
                ShowStatus:     true,
                ShowHelp:       true,
                UpdateInterval: 1 * time.Second,
                Theme:          "default",
                KeyBindings: map[string]string{
                        "quit":         "q",
                        "terminals":    "1",
                        "templates":    "2",
                        "settings":     "3",
                        "up":           "k",
                        "down":         "j",
                        "enter":        "enter",
                        "escape":       "esc",
                },
        }
}</span>

// AppState 應用狀態
type AppState struct {
        Running        bool
        TerminalCount  int
        ActiveTerminal string
        LastQuery      string
        SystemHealth   string
}

// KeyMap 按鍵映射
type KeyMap struct {
        Up     tea.KeyMsg
        Down   tea.KeyMsg
        Enter  tea.KeyMsg
        Escape tea.KeyMsg
        Quit   tea.KeyMsg
        Help   tea.KeyMsg
}

// DefaultKeyMap 返回默認按鍵映射
func DefaultKeyMap() KeyMap <span class="cov0" title="0">{
        return KeyMap{
                Up:     tea.KeyMsg{Type: tea.KeyUp},
                Down:   tea.KeyMsg{Type: tea.KeyDown},
                Enter:  tea.KeyMsg{Type: tea.KeyEnter},
                Escape: tea.KeyMsg{Type: tea.KeyEsc},
                Quit:   tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}},
                Help:   tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'?'}},
        }
}</span>

// MenuItem 菜單項
type MenuItem struct {
        Title       string
        Description string
        Action      string
        Shortcut    string
        Enabled     bool
}

// Menu 菜單結構
type Menu struct {
        Title        string
        Items        []MenuItem
        SelectedItem int
        MaxDisplay   int
}

// Theme 主題配置
type Theme struct {
        Primary   string
        Secondary string
        Success   string
        Warning   string
        Error     string
        Muted     string
        Border    string
        Highlight string
}

// DefaultTheme 返回默認主題
func DefaultTheme() Theme <span class="cov0" title="0">{
        return Theme{
                Primary:   "#007ACC",
                Secondary: "#6C7B7F",
                Success:   "#28A745",
                Warning:   "#FFC107",
                Error:     "#DC3545",
                Muted:     "#6C757D",
                Border:    "#E9ECEF",
                Highlight: "#FFF3CD",
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
