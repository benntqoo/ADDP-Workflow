
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">claude-proxy/cmd/proxy/main.go (0.0%)</option>
				
				<option value="file1">claude-proxy/internal/terminal/manager.go (77.2%)</option>
				
				<option value="file2">claude-proxy/internal/terminal/platform.go (55.9%)</option>
				
				<option value="file3">claude-proxy/internal/terminal/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "claude-proxy",
        Short: "AI Terminal Proxy - 統一所有 AI CLI 工具的終端界面",
        Long: `AI Terminal Proxy 是一個智能終端代理，提供：
• 統一的 GUI 界面管理多個 AI 終端
• Ollama 本地查詢優化，節省 30-50% token
• 1-4 數字鍵快速在不同 AI 工具間切換
• 支援 Claude Code、Gemini CLI、Cursor、Aider`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("🤖 AI Terminal Proxy v1.0")
                fmt.Println("啟動 TUI 界面...")
                // TODO: 啟動 Bubble Tea TUI 界面
        }</span>,
}

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "顯示版本信息",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("claude-proxy v1.0.0")
                fmt.Println("基於雙軌架構：Golang 終端代理 + Python MCP 工具")
        }</span>,
}

var listCmd = &amp;cobra.Command{
        Use:   "list-terminals",
        Short: "列出可用的終端類型",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("可用終端類型：")
                fmt.Println("  1. claude     - Claude Code CLI")
                fmt.Println("  2. gemini     - Gemini CLI")
                fmt.Println("  3. cursor     - Cursor CLI")
                fmt.Println("  4. aider      - Aider CLI")
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(listCmd)
}</span>

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package terminal

import (
        "bufio"
        "context"
        "fmt"
        "os/exec"
        "sync"
        "time"
)

// TerminalManager 實現 Manager 接口
type TerminalManager struct {
        terminals map[string]*Terminal
        mu        sync.RWMutex
        healthy   bool
}

// NewTerminalManager 創建一個新的終端管理器
func NewTerminalManager() *TerminalManager <span class="cov8" title="1">{
        return &amp;TerminalManager{
                terminals: make(map[string]*Terminal),
                healthy:   true,
        }
}</span>

// StartTerminal 啟動指定的終端
func (tm *TerminalManager) StartTerminal(config TerminalConfig) error <span class="cov8" title="1">{
        return tm.StartTerminalWithContext(context.Background(), config)
}</span>

// StartTerminalWithContext 使用上下文啟動指定的終端
func (tm *TerminalManager) StartTerminalWithContext(ctx context.Context, config TerminalConfig) error <span class="cov8" title="1">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        // 檢查終端是否已存在
        if _, exists := tm.terminals[config.Name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' already exists", config.Name)
        }</span>

        // 創建新的終端實例
        <span class="cov8" title="1">terminal := &amp;Terminal{
                Name:     config.Name,
                Type:     config.Type,
                Status:   StatusStarting,
                LastUsed: time.Now().Unix(),
        }

        // 創建命令
        cmd := tm.createCommand(config)
        if cmd == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create command for terminal type %s", config.Type.String())
        }</span>

        <span class="cov8" title="1">terminal.Process = cmd

        // 設置輸入輸出管道
        if err := tm.setupPipes(terminal); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup pipes: %w", err)
        }</span>

        // 在後台啟動進程
        <span class="cov8" title="1">if err := tm.startProcess(ctx, terminal); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start process: %w", err)
        }</span>

        // 添加到管理器
        <span class="cov8" title="1">tm.terminals[config.Name] = terminal
        terminal.SetStatus(StatusRunning)

        return nil</span>
}

// StopTerminal 停止指定名稱的終端
func (tm *TerminalManager) StopTerminal(name string) error <span class="cov8" title="1">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        terminal, exists := tm.terminals[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' not found", name)
        }</span>

        // 設置停止狀態
        <span class="cov8" title="1">terminal.SetStatus(StatusStopping)

        // 停止進程
        if terminal.Process != nil &amp;&amp; terminal.Process.Process != nil </span><span class="cov8" title="1">{
                if err := terminal.Process.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        terminal.SetStatus(StatusError)
                        return fmt.Errorf("failed to kill process: %w", err)
                }</span>
        }

        // 等待進程結束
        <span class="cov8" title="1">if terminal.Process != nil </span><span class="cov8" title="1">{
                _ = terminal.Process.Wait()
        }</span>

        <span class="cov8" title="1">terminal.SetStatus(StatusStopped)
        return nil</span>
}

// SendCommand 向指定終端發送命令
func (tm *TerminalManager) SendCommand(name string, command string) error <span class="cov8" title="1">{
        tm.mu.RLock()
        terminal, exists := tm.terminals[name]
        tm.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' not found", name)
        }</span>

        <span class="cov8" title="1">if !terminal.IsRunning() </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' is not running", name)
        }</span>

        // 更新最後使用時間
        <span class="cov8" title="1">terminal.mu.Lock()
        terminal.LastUsed = time.Now().Unix()
        terminal.mu.Unlock()

        // 發送命令
        if terminal.Stdin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("terminal '%s' stdin not available", name)
        }</span>

        <span class="cov8" title="1">if _, err := terminal.Stdin.WriteString(command + "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write command: %w", err)
        }</span>

        <span class="cov8" title="1">if err := terminal.Stdin.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush command: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetTerminal 獲取指定名稱的終端
func (tm *TerminalManager) GetTerminal(name string) (*Terminal, bool) <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        terminal, exists := tm.terminals[name]
        return terminal, exists
}</span>

// ListTerminals 列出所有終端
func (tm *TerminalManager) ListTerminals() []*Terminal <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        terminals := make([]*Terminal, 0, len(tm.terminals))
        for _, terminal := range tm.terminals </span><span class="cov8" title="1">{
                terminals = append(terminals, terminal)
        }</span>

        <span class="cov8" title="1">return terminals</span>
}

// IsHealthy 檢查終端管理器是否健康
func (tm *TerminalManager) IsHealthy() bool <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        return tm.healthy
}</span>

// createCommand 創建對應類型的命令
func (tm *TerminalManager) createCommand(config TerminalConfig) *exec.Cmd <span class="cov8" title="1">{
        var cmd *exec.Cmd

        switch config.Type </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                cmd = exec.Command("claude")</span>
        case TypeGeminiCLI:<span class="cov0" title="0">
                cmd = exec.Command("gemini")</span>
        case TypeCursor:<span class="cov0" title="0">
                cmd = exec.Command("cursor", "--cli")</span>
        case TypeAider:<span class="cov0" title="0">
                cmd = exec.Command("aider")</span>
        case TypeCustom:<span class="cov8" title="1">
                // 對於測試，使用一個簡單的命令
                cmd = exec.Command("echo", "test")</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        // 設置工作目錄
        <span class="cov8" title="1">if config.WorkingDir != "" </span><span class="cov8" title="1">{
                cmd.Dir = config.WorkingDir
        }</span>

        // 設置環境變量
        <span class="cov8" title="1">if config.Environment != nil </span><span class="cov0" title="0">{
                for key, value := range config.Environment </span><span class="cov0" title="0">{
                        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // 添加額外參數
        <span class="cov8" title="1">if config.Args != nil </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, config.Args...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// setupPipes 設置進程的輸入輸出管道
func (tm *TerminalManager) setupPipes(terminal *Terminal) error <span class="cov8" title="1">{
        // 設置標準輸入管道
        stdin, err := terminal.Process.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>
        <span class="cov8" title="1">terminal.Stdin = bufio.NewWriter(stdin)

        // 設置標準輸出管道
        stdout, err := terminal.Process.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>
        <span class="cov8" title="1">terminal.Stdout = bufio.NewScanner(stdout)

        return nil</span>
}

// startProcess 在後台啟動進程
func (tm *TerminalManager) startProcess(ctx context.Context, terminal *Terminal) error <span class="cov8" title="1">{
        // 創建一個帶取消功能的上下文
        processCtx, cancel := context.WithCancel(ctx)
        defer cancel()

        // 設置超時
        done := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                done &lt;- terminal.Process.Start()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        terminal.SetStatus(StatusError)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-processCtx.Done():<span class="cov0" title="0">
                terminal.SetStatus(StatusError)
                return processCtx.Err()</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"> // 5秒超時
                terminal.SetStatus(StatusError)
                return fmt.Errorf("timeout starting process")</span>
        }
}</pre>
		
		<pre class="file" id="file2" style="display: none">package terminal

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
)

// PlatformAdapter 提供跨平台的終端管理功能
type PlatformAdapter struct {
        os string
}

// NewPlatformAdapter 創建新的平台適配器
func NewPlatformAdapter() *PlatformAdapter <span class="cov8" title="1">{
        return &amp;PlatformAdapter{
                os: runtime.GOOS,
        }
}</span>

// GetDefaultShell 獲取當前平台的默認 shell
func (pa *PlatformAdapter) GetDefaultShell() string <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 優先使用 PowerShell，備選 cmd
                if pa.ValidateCommand("powershell.exe") </span><span class="cov8" title="1">{
                        return "powershell.exe"
                }</span>
                <span class="cov0" title="0">return "cmd.exe"</span>
        case "darwin", "linux":<span class="cov0" title="0">
                // Unix-like 系統優先使用 bash，備選 sh
                if pa.ValidateCommand("/bin/bash") </span><span class="cov0" title="0">{
                        return "/bin/bash"
                }</span>
                <span class="cov0" title="0">return "/bin/sh"</span>
        default:<span class="cov0" title="0">
                // 其他系統使用通用 shell
                return "/bin/sh"</span>
        }
}

// GetExecutablePath 獲取命令的完整可執行路徑
func (pa *PlatformAdapter) GetExecutablePath(command string) string <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 系統處理
                extensions := []string{"", ".exe", ".cmd", ".bat", ".com"}

                for _, ext := range extensions </span><span class="cov8" title="1">{
                        fullCommand := command + ext
                        if path, err := exec.LookPath(fullCommand); err == nil </span><span class="cov8" title="1">{
                                return path
                        }</span>
                }

                // 如果沒找到，返回帶 .exe 的版本
                <span class="cov8" title="1">return command + ".exe"</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統
                if path, err := exec.LookPath(command); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>

                // 如果沒找到，返回原命令（可能在 PATH 中）
                <span class="cov0" title="0">return command</span>
        }
}

// CreateCommand 創建適合當前平台的命令
func (pa *PlatformAdapter) CreateCommand(config TerminalConfig) *exec.Cmd <span class="cov8" title="1">{
        var cmdPath string
        var args []string

        switch config.Type </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("claude")
                args = []string{cmdPath}</span>

        case TypeGeminiCLI:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("gemini")
                args = []string{cmdPath}</span>

        case TypeCursor:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("cursor")
                args = []string{cmdPath, "--cli"}</span>

        case TypeAider:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("aider")
                args = []string{cmdPath}</span>

        case TypeCustom:<span class="cov8" title="1">
                // 對於測試，使用平台適當的測試命令
                if pa.os == "windows" </span><span class="cov8" title="1">{
                        cmdPath = pa.GetExecutablePath("cmd")
                        args = []string{cmdPath, "/c", "echo", "test"}
                }</span> else<span class="cov0" title="0"> {
                        cmdPath = "/bin/echo"
                        args = []string{cmdPath, "test"}
                }</span>

        default:<span class="cov0" title="0">
                // 默認使用 shell
                cmdPath = pa.GetDefaultShell()
                args = []string{cmdPath}</span>
        }

        // 創建命令
        <span class="cov8" title="1">cmd := &amp;exec.Cmd{
                Path: cmdPath,
                Args: args,
        }

        // 設置工作目錄
        if config.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = config.WorkingDir
        }</span>

        // 添加額外參數
        <span class="cov8" title="1">if config.Args != nil </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, config.Args...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// SetupEnvironment 設置命令的環境變量
func (pa *PlatformAdapter) SetupEnvironment(cmd *exec.Cmd, config TerminalConfig) <span class="cov8" title="1">{
        // 獲取當前環境變量
        env := os.Environ()

        // 添加自定義環境變量
        if config.Environment != nil </span><span class="cov8" title="1">{
                for key, value := range config.Environment </span><span class="cov8" title="1">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // 添加平台特定的環境變量
        <span class="cov8" title="1">switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 特定環境設置
                env = append(env, "AI_TERMINAL_PLATFORM=windows")

                // 確保 PATH 包含必要的目錄
                pathEnvVar := pa.findPathVariable(env)
                if pathEnvVar == "" </span><span class="cov0" title="0">{
                        env = append(env, "PATH=C:\\Windows\\System32")
                }</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統特定環境設置
                env = append(env, "AI_TERMINAL_PLATFORM=unix")

                // 確保基本的 PATH
                pathEnvVar := pa.findPathVariable(env)
                if pathEnvVar == "" </span><span class="cov0" title="0">{
                        env = append(env, "PATH=/usr/local/bin:/usr/bin:/bin")
                }</span>
        }

        <span class="cov8" title="1">cmd.Env = env</span>
}

// ValidateCommand 檢查命令是否存在
func (pa *PlatformAdapter) ValidateCommand(command string) bool <span class="cov8" title="1">{
        // 如果是絕對路徑，直接檢查文件是否存在
        if filepath.IsAbs(command) </span><span class="cov0" title="0">{
                _, err := os.Stat(command)
                return err == nil
        }</span>

        // 使用 exec.LookPath 在 PATH 中查找
        <span class="cov8" title="1">_, err := exec.LookPath(command)
        return err == nil</span>
}

// GetProcessInfo 獲取進程信息
func (pa *PlatformAdapter) GetProcessInfo(pid int) *ProcessInfo <span class="cov8" title="1">{
        info := &amp;ProcessInfo{
                PID: pid,
        }

        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 使用 WMI 或 tasklist 獲取進程信息
                info.Command = pa.getWindowsProcessInfo(pid)
                info.ExecutablePath = pa.getWindowsExecutablePath(pid)
                info.Status = "running"</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統使用 /proc 或 ps
                info.Command = pa.getUnixProcessInfo(pid)
                info.CommandLine = pa.getUnixCommandLine(pid)
                info.Status = "running"</span>
        }

        <span class="cov8" title="1">return info</span>
}

// KillProcess 跨平台殺死進程
func (pa *PlatformAdapter) KillProcess(pid int) error <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows 使用 taskkill
                cmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", pid))
                return cmd.Run()</span>

        default:<span class="cov0" title="0">
                // Unix-like 系統使用 kill
                cmd := exec.Command("kill", "-TERM", fmt.Sprintf("%d", pid))
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        // 如果 TERM 失敗，嘗試 KILL
                        cmd = exec.Command("kill", "-KILL", fmt.Sprintf("%d", pid))
                        return cmd.Run()
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// 輔助方法：查找 PATH 環境變量
func (pa *PlatformAdapter) findPathVariable(env []string) string <span class="cov8" title="1">{
        for _, envVar := range env </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.ToUpper(envVar), "PATH=") </span><span class="cov8" title="1">{
                        return envVar
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Windows 特定的進程信息獲取
func (pa *PlatformAdapter) getWindowsProcessInfo(pid int) string <span class="cov8" title="1">{
        // 簡化實現：在實際項目中可能需要使用 WMI
        cmd := exec.Command("tasklist", "/FI", fmt.Sprintf("PID eq %d", pid), "/FO", "CSV", "/NH")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        // 解析 CSV 輸出獲取進程名
        <span class="cov8" title="1">lines := strings.Split(string(output), "\n")
        if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov8" title="1">{
                fields := strings.Split(lines[0], ",")
                if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                        // 移除引號
                        return strings.Trim(fields[0], "\"")
                }</span>
        }

        <span class="cov0" title="0">return "unknown"</span>
}

// Windows 獲取可執行文件路徑
func (pa *PlatformAdapter) getWindowsExecutablePath(pid int) string <span class="cov8" title="1">{
        // 簡化實現：實際項目中可能需要使用 Windows API
        return "unknown"
}</span>

// Unix 特定的進程信息獲取
func (pa *PlatformAdapter) getUnixProcessInfo(pid int) string <span class="cov0" title="0">{
        // 嘗試從 /proc/PID/comm 讀取進程名
        commPath := fmt.Sprintf("/proc/%d/comm", pid)
        if data, err := os.ReadFile(commPath); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(string(data))
        }</span>

        // 備選：使用 ps 命令
        <span class="cov0" title="0">cmd := exec.Command("ps", "-p", fmt.Sprintf("%d", pid), "-o", "comm=")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// Unix 獲取命令行
func (pa *PlatformAdapter) getUnixCommandLine(pid int) string <span class="cov0" title="0">{
        // 嘗試從 /proc/PID/cmdline 讀取命令行
        cmdlinePath := fmt.Sprintf("/proc/%d/cmdline", pid)
        if data, err := os.ReadFile(cmdlinePath); err == nil </span><span class="cov0" title="0">{
                // /proc/PID/cmdline 使用 null 字符分隔參數
                cmdline := strings.ReplaceAll(string(data), "\x00", " ")
                return strings.TrimSpace(cmdline)
        }</span>

        // 備選：使用 ps 命令
        <span class="cov0" title="0">cmd := exec.Command("ps", "-p", fmt.Sprintf("%d", pid), "-o", "args=")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// ProcessInfo 跨平台進程信息結構
type ProcessInfo struct {
        PID            int    // 進程 ID
        Command        string // 進程命令名
        CommandLine    string // 完整命令行
        ExecutablePath string // 可執行文件路徑
        Status         string // 進程狀態
}</pre>
		
		<pre class="file" id="file3" style="display: none">package terminal

import (
        "bufio"
        "os/exec"
        "sync"
)

// TerminalType 表示支援的 AI 終端類型
type TerminalType int

const (
        TypeClaudeCode TerminalType = iota // Claude Code CLI
        TypeGeminiCLI                      // Gemini CLI
        TypeCursor                         // Cursor CLI
        TypeAider                          // Aider CLI
        TypeCustom                         // 自定義終端
)

// String 返回終端類型的字符串表示
func (t TerminalType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                return "claude"</span>
        case TypeGeminiCLI:<span class="cov8" title="1">
                return "gemini"</span>
        case TypeCursor:<span class="cov8" title="1">
                return "cursor"</span>
        case TypeAider:<span class="cov8" title="1">
                return "aider"</span>
        case TypeCustom:<span class="cov8" title="1">
                return "custom"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// CommandName 返回終端類型對應的命令名
func (t TerminalType) CommandName() string <span class="cov8" title="1">{
        switch t </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                return "claude"</span>
        case TypeGeminiCLI:<span class="cov8" title="1">
                return "gemini"</span>
        case TypeCursor:<span class="cov8" title="1">
                return "cursor"</span>
        case TypeAider:<span class="cov8" title="1">
                return "aider"</span>
        default:<span class="cov8" title="1">
                return "bash"</span>
        }
}

// TerminalStatus 表示終端狀態
type TerminalStatus int

const (
        StatusStopped TerminalStatus = iota // 已停止
        StatusStarting                      // 啟動中
        StatusRunning                       // 運行中
        StatusStopping                      // 停止中
        StatusError                         // 錯誤狀態
)

// String 返回終端狀態的字符串表示
func (s TerminalStatus) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StatusStopped:<span class="cov8" title="1">
                return "stopped"</span>
        case StatusStarting:<span class="cov8" title="1">
                return "starting"</span>
        case StatusRunning:<span class="cov8" title="1">
                return "running"</span>
        case StatusStopping:<span class="cov8" title="1">
                return "stopping"</span>
        case StatusError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Terminal 表示一個 AI 終端實例
type Terminal struct {
        Name     string         // 終端名稱
        Type     TerminalType   // 終端類型
        Status   TerminalStatus // 終端狀態
        Process  *exec.Cmd      // 底層進程
        Stdin    *bufio.Writer  // 標準輸入寫入器
        Stdout   *bufio.Scanner // 標準輸出掃描器
        LastUsed int64          // 最後使用時間戳
        mu       sync.RWMutex   // 保護並發訪問的鎖
}

// GetStatus 安全地獲取終端狀態
func (t *Terminal) GetStatus() TerminalStatus <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.Status
}</span>

// SetStatus 安全地設置終端狀態
func (t *Terminal) SetStatus(status TerminalStatus) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.Status = status
}</span>

// IsRunning 檢查終端是否正在運行
func (t *Terminal) IsRunning() bool <span class="cov8" title="1">{
        return t.GetStatus() == StatusRunning
}</span>

// TerminalConfig 終端配置
type TerminalConfig struct {
        Type        TerminalType          // 終端類型
        Name        string                // 終端名稱
        WorkingDir  string                // 工作目錄
        Environment map[string]string     // 環境變量
        Args        []string              // 額外參數
}

// Manager 介面定義終端管理器的行為
type Manager interface {
        // StartTerminal 啟動指定的終端
        StartTerminal(config TerminalConfig) error

        // StopTerminal 停止指定名稱的終端
        StopTerminal(name string) error

        // SendCommand 向指定終端發送命令
        SendCommand(name string, command string) error

        // GetTerminal 獲取指定名稱的終端
        GetTerminal(name string) (*Terminal, bool)

        // ListTerminals 列出所有終端
        ListTerminals() []*Terminal

        // IsHealthy 檢查終端管理器是否健康
        IsHealthy() bool
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
