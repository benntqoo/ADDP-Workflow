
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">claude-proxy/cmd/proxy/main.go (0.0%)</option>
				
				<option value="file1">claude-proxy/internal/ollama/client.go (45.2%)</option>
				
				<option value="file2">claude-proxy/internal/template/manager.go (87.0%)</option>
				
				<option value="file3">claude-proxy/internal/template/types.go (0.0%)</option>
				
				<option value="file4">claude-proxy/internal/terminal/manager.go (77.2%)</option>
				
				<option value="file5">claude-proxy/internal/terminal/platform.go (55.9%)</option>
				
				<option value="file6">claude-proxy/internal/terminal/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "claude-proxy",
        Short: "AI Terminal Proxy - çµ±ä¸€æ‰€æœ‰ AI CLI å·¥å…·çš„çµ‚ç«¯ç•Œé¢",
        Long: `AI Terminal Proxy æ˜¯ä¸€å€‹æ™ºèƒ½çµ‚ç«¯ä»£ç†ï¼Œæä¾›ï¼š
â€¢ çµ±ä¸€çš„ GUI ç•Œé¢ç®¡ç†å¤šå€‹ AI çµ‚ç«¯
â€¢ Ollama æœ¬åœ°æŸ¥è©¢å„ªåŒ–ï¼Œç¯€çœ 30-50% token
â€¢ 1-4 æ•¸å­—éµå¿«é€Ÿåœ¨ä¸åŒ AI å·¥å…·é–“åˆ‡æ›
â€¢ æ”¯æ´ Claude Codeã€Gemini CLIã€Cursorã€Aider`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("ğŸ¤– AI Terminal Proxy v1.0")
                fmt.Println("å•Ÿå‹• TUI ç•Œé¢...")
                // TODO: å•Ÿå‹• Bubble Tea TUI ç•Œé¢
        }</span>,
}

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "é¡¯ç¤ºç‰ˆæœ¬ä¿¡æ¯",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("claude-proxy v1.0.0")
                fmt.Println("åŸºæ–¼é›™è»Œæ¶æ§‹ï¼šGolang çµ‚ç«¯ä»£ç† + Python MCP å·¥å…·")
        }</span>,
}

var listCmd = &amp;cobra.Command{
        Use:   "list-terminals",
        Short: "åˆ—å‡ºå¯ç”¨çš„çµ‚ç«¯é¡å‹",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("å¯ç”¨çµ‚ç«¯é¡å‹ï¼š")
                fmt.Println("  1. claude     - Claude Code CLI")
                fmt.Println("  2. gemini     - Gemini CLI")
                fmt.Println("  3. cursor     - Cursor CLI")
                fmt.Println("  4. aider      - Aider CLI")
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(listCmd)
}</span>

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package ollama

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
)

// NewOllamaClient å‰µå»ºæ–°çš„ Ollama å®¢æˆ¶ç«¯
func NewOllamaClient(baseURL string) *OllamaClient <span class="cov8" title="1">{
        return &amp;OllamaClient{
                BaseURL: baseURL,
                HTTPClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                Model: "qwen2.5:14b", // é»˜èªæ¨¡å‹
        }
}</span>

// IsHealthy æª¢æŸ¥ Ollama æœå‹™æ˜¯å¦å¥åº·
func (c *OllamaClient) IsHealthy(ctx context.Context) bool <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+"/api/tags", nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK</span>
}

// OptimizeQuery ä½¿ç”¨ Ollama å„ªåŒ–æŸ¥è©¢
func (c *OllamaClient) OptimizeQuery(ctx context.Context, query, queryContext string) (*OptimizationResult, error) <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" </span><span class="cov8" title="1">{
                return &amp;OptimizationResult{}, fmt.Errorf("query cannot be empty")
        }</span>

        <span class="cov8" title="1">startTime := time.Now()

        // æ§‹å»ºå„ªåŒ–æç¤ºè©
        prompt := c.buildOptimizationPrompt(query, queryContext)

        // ç™¼é€ç”Ÿæˆè«‹æ±‚
        generateResp, err := c.sendGenerateRequest(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;OptimizationResult{}, err
        }</span>

        <span class="cov0" title="0">processingTime := time.Since(startTime)

        // è¨ˆç®—ä¼°ç®—çš„ token æ•¸é‡
        tokensUsed := c.calculateTokens(generateResp.Response)

        return &amp;OptimizationResult{
                OriginalQuery:   query,
                OptimizedQuery:  strings.TrimSpace(generateResp.Response),
                Model:          generateResp.Model,
                ProcessingTime: processingTime,
                TokensUsed:     tokensUsed,
                Confidence:     0.8, // å›ºå®šä¿¡å¿ƒåº¦ï¼Œå¯¦éš›å¯¦ç¾ä¸­å¯èƒ½æœƒæ›´å¾©é›œ
        }, nil</span>
}

// GetAvailableModels ç²å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
func (c *OllamaClient) GetAvailableModels(ctx context.Context) ([]ModelInfo, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+"/api/tags", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ollama returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">var listResp ListModelsResponse
        if err := json.Unmarshal(body, &amp;listResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // æ¨™è¨˜æ‰€æœ‰æ¨¡å‹ç‚ºå¯ç”¨
        <span class="cov0" title="0">for i := range listResp.Models </span><span class="cov0" title="0">{
                listResp.Models[i].Available = true
        }</span>

        <span class="cov0" title="0">return listResp.Models, nil</span>
}

// ValidateModel é©—è­‰æ¨¡å‹æ˜¯å¦å¯ç”¨
func (c *OllamaClient) ValidateModel(ctx context.Context, modelName string) bool <span class="cov8" title="1">{
        if strings.TrimSpace(modelName) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">models, err := c.GetAvailableModels(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">for _, model := range models </span><span class="cov0" title="0">{
                if model.Name == modelName </span><span class="cov0" title="0">{
                        return model.Available
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// SetModel è¨­ç½®é»˜èªæ¨¡å‹
func (c *OllamaClient) SetModel(model string) <span class="cov0" title="0">{
        c.Model = model
}</span>

// GetModel ç²å–ç•¶å‰é»˜èªæ¨¡å‹
func (c *OllamaClient) GetModel() string <span class="cov0" title="0">{
        return c.Model
}</span>

// buildOptimizationPrompt æ§‹å»ºæŸ¥è©¢å„ªåŒ–æç¤ºè©
func (c *OllamaClient) buildOptimizationPrompt(query, queryContext string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`è«‹å„ªåŒ–ä»¥ä¸‹æŸ¥è©¢ï¼Œè®“å®ƒæ›´æ¸…æ™°ã€å…·é«”å’Œæœ‰æ•ˆï¼š

åŸå§‹æŸ¥è©¢: %s
ä¸Šä¸‹æ–‡: %s

è«‹æä¾›å„ªåŒ–å¾Œçš„æŸ¥è©¢ï¼Œåªè¿”å›å„ªåŒ–å¾Œçš„æŸ¥è©¢å…§å®¹ï¼Œä¸è¦åŒ…å«å…¶ä»–è§£é‡‹æ–‡å­—ã€‚`, query, queryContext)
}</span>

// calculateTokens ä¼°ç®— token æ•¸é‡
func (c *OllamaClient) calculateTokens(text string) int <span class="cov0" title="0">{
        // ç°¡å–®ä¼°ç®—ï¼šä¸­æ–‡å­—ç¬¦æŒ‰ 1 å€‹ tokenï¼Œè‹±æ–‡å­—ç¬¦æŒ‰ 1/4 å€‹ token
        tokens := 0
        for _, r := range text </span><span class="cov0" title="0">{
                if r &gt; 127 </span><span class="cov0" title="0">{ // é ASCII å­—ç¬¦ï¼ˆä¸»è¦æ˜¯ä¸­æ–‡ï¼‰
                        tokens++
                }</span> else<span class="cov0" title="0"> {
                        tokens += 1 // è‹±æ–‡å­—ç¬¦è¨ˆç‚º 0.25 tokenï¼Œä½†è‡³å°‘ 1
                }</span>
        }
        <span class="cov0" title="0">return tokens / 4</span> // å¹³å‡åŒ–è™•ç†
}

// sendGenerateRequest ç™¼é€ç”Ÿæˆè«‹æ±‚çš„é€šç”¨æ–¹æ³•
func (c *OllamaClient) sendGenerateRequest(ctx context.Context, prompt string) (*GenerateResponse, error) <span class="cov8" title="1">{
        generateReq := GenerateRequest{
                Model:  c.Model,
                Prompt: prompt,
                Stream: false,
        }

        reqBody, err := json.Marshal(generateReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+"/api/generate", bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ollama returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var generateResp GenerateResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;generateResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;generateResp, nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package template

import (
        "fmt"
        "regexp"
        "strings"
        "text/template"
        "time"
)

// NewTemplateManager å‰µå»ºæ–°çš„æ¨¡æ¿ç®¡ç†å™¨
func NewTemplateManager() *TemplateManager <span class="cov8" title="1">{
        manager := &amp;TemplateManager{
                templates:     make(map[string]*QueryTemplate),
                templateCache: make(map[string]*template.Template),
                stats:         make(map[string]*TemplateStats),
                config: &amp;TemplateConfig{
                        EnableStats:    true,
                        MaxCustom:     50,
                        CacheSize:     100,
                        ValidateStrict: false,
                },
        }

        // åˆå§‹åŒ–å…§å»ºæ¨¡æ¿
        manager.initBuiltInTemplates()

        return manager
}</span>

// GetAvailableTemplates ç²å–æ‰€æœ‰å¯ç”¨æ¨¡æ¿
func (tm *TemplateManager) GetAvailableTemplates() []*QueryTemplate <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        templates := make([]*QueryTemplate, 0, len(tm.templates))
        for _, tmpl := range tm.templates </span><span class="cov8" title="1">{
                templates = append(templates, tmpl)
        }</span>

        <span class="cov8" title="1">return templates</span>
}

// GetTemplate æ ¹æ“š ID ç²å–æ¨¡æ¿
func (tm *TemplateManager) GetTemplate(templateID string) (*QueryTemplate, bool) <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        template, exists := tm.templates[templateID]
        return template, exists
}</span>

// ApplyTemplate æ‡‰ç”¨æ¨¡æ¿åˆ°ç”¨æˆ¶æŸ¥è©¢
func (tm *TemplateManager) ApplyTemplate(templateID, userQuery string, context map[string]string) (*ApplyResult, error) <span class="cov8" title="1">{
        if strings.TrimSpace(userQuery) == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user query cannot be empty")
        }</span>

        <span class="cov8" title="1">template, exists := tm.GetTemplate(templateID)
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("template not found: %s", templateID)
        }</span>

        // æº–å‚™æ¨¡æ¿æ•¸æ“š
        <span class="cov8" title="1">data := make(map[string]string)
        data["query"] = userQuery

        // æ·»åŠ ç”¨æˆ¶æä¾›çš„ä¸Šä¸‹æ–‡
        if context != nil </span><span class="cov8" title="1">{
                for key, value := range context </span><span class="cov8" title="1">{
                        data[key] = value
                }</span>
        }

        // æ¸²æŸ“æ¨¡æ¿
        <span class="cov8" title="1">optimizedPrompt, err := tm.renderTemplate(template.Prompt, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to render template: %w", err)
        }</span>

        // è¨ˆç®— token ä¼°ç®—
        <span class="cov8" title="1">tokensEstimate := tm.estimateTokens(optimizedPrompt)

        // æ›´æ–°çµ±è¨ˆ
        tm.updateStats(templateID, tokensEstimate)

        return &amp;ApplyResult{
                TemplateID:      templateID,
                OriginalQuery:   userQuery,
                OptimizedPrompt: optimizedPrompt,
                Context:         context,
                AppliedAt:       time.Now(),
                TokensEstimate:  tokensEstimate,
        }, nil</span>
}

// GetTemplatesByCategory æ ¹æ“šåˆ†é¡ç²å–æ¨¡æ¿
func (tm *TemplateManager) GetTemplatesByCategory(category string) []*QueryTemplate <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        var templates []*QueryTemplate
        for _, tmpl := range tm.templates </span><span class="cov8" title="1">{
                if tmpl.Category == category </span><span class="cov8" title="1">{
                        templates = append(templates, tmpl)
                }</span>
        }

        <span class="cov8" title="1">return templates</span>
}

// ValidateTemplate é©—è­‰æ¨¡æ¿
func (tm *TemplateManager) ValidateTemplate(tmpl *QueryTemplate) bool <span class="cov8" title="1">{
        if tmpl == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // æª¢æŸ¥å¿…éœ€å­—æ®µ
        <span class="cov8" title="1">if strings.TrimSpace(tmpl.ID) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(tmpl.Prompt) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // é©—è­‰æ¨¡æ¿èªæ³•
        <span class="cov8" title="1">_, err := template.New("test").Parse(tmpl.Prompt)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // æª¢æŸ¥è®Šé‡ä¸€è‡´æ€§
        <span class="cov8" title="1">return tm.validateTemplateVariables(tmpl)</span>
}

// AddCustomTemplate æ·»åŠ è‡ªå®šç¾©æ¨¡æ¿
func (tm *TemplateManager) AddCustomTemplate(tmpl *QueryTemplate) error <span class="cov8" title="1">{
        if !tm.ValidateTemplate(tmpl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template")
        }</span>

        <span class="cov8" title="1">tm.mu.Lock()
        defer tm.mu.Unlock()

        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if _, exists := tm.templates[tmpl.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("template already exists: %s", tmpl.ID)
        }</span>

        // è¨­ç½®å‰µå»ºæ™‚é–“
        <span class="cov8" title="1">if tmpl.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                tmpl.CreatedAt = time.Now()
        }</span>
        <span class="cov8" title="1">tmpl.UpdatedAt = time.Now()
        tmpl.IsBuiltIn = false

        tm.templates[tmpl.ID] = tmpl
        return nil</span>
}

// initBuiltInTemplates åˆå§‹åŒ–å…§å»ºæ¨¡æ¿
func (tm *TemplateManager) initBuiltInTemplates() <span class="cov8" title="1">{
        builtInTemplates := []*QueryTemplate{
                {
                        ID:          TemplateCoding,
                        Name:        "ç·¨ç¢¼æ¨¡æ¿",
                        Description: "ç”¨æ–¼ä»£ç¢¼é–‹ç™¼å’Œå¯¦ç¾çš„å„ªåŒ–æ¨¡æ¿",
                        Category:    CategoryDevelopment,
                        Prompt: `ä½œç‚ºä¸€åè³‡æ·±{{.language}}é–‹ç™¼è€…ï¼Œè«‹å¹«åŠ©æˆ‘{{.query}}ã€‚

è«‹è€ƒæ…®ä»¥ä¸‹è¦æ±‚ï¼š
- ä½¿ç”¨æœ€ä½³å¯¦è¸å’Œç·¨ç¢¼è¦ç¯„
- æä¾›æ¸…æ™°çš„ä»£ç¢¼è¨»é‡‹
- è€ƒæ…®éŒ¯èª¤è™•ç†å’Œé‚Šç•Œæƒ…æ³
- è¤‡é›œåº¦ï¼š{{.complexity}}
{{if .framework}}
- ä½¿ç”¨æ¡†æ¶ï¼š{{.framework}}
{{end}}

è«‹æä¾›è©³ç´°çš„å¯¦ç¾æ–¹æ¡ˆå’Œä»£ç¢¼ç¤ºä¾‹ã€‚`,
                        Variables: []string{"query", "language", "complexity", "framework"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateDebug,
                        Name:        "èª¿è©¦æ¨¡æ¿",
                        Description: "ç”¨æ–¼å•é¡Œè¨ºæ–·å’ŒéŒ¯èª¤ä¿®å¾©çš„å„ªåŒ–æ¨¡æ¿",
                        Category:    CategoryMaintenance,
                        Prompt: `ä½œç‚ºèª¿è©¦å°ˆå®¶ï¼Œè«‹å¹«åŠ©æˆ‘åˆ†æå’Œè§£æ±ºä»¥ä¸‹å•é¡Œï¼š

å•é¡Œæè¿°ï¼š{{.query}}

ç›¸é—œä¿¡æ¯ï¼š
- ç¨‹å¼èªè¨€ï¼š{{.language}}
- éŒ¯èª¤é¡å‹ï¼š{{.error_type}}
{{if .stack_trace}}
- å †ç–Šè¿½è¹¤ï¼š{{.stack_trace}}
{{end}}

è«‹æä¾›ï¼š
1. å•é¡Œæ ¹å› åˆ†æ
2. å…·é«”çš„è§£æ±ºæ–¹æ¡ˆ
3. é é˜²æªæ–½å»ºè­°`,
                        Variables: []string{"query", "language", "error_type", "stack_trace"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateRefactor,
                        Name:        "é‡æ§‹æ¨¡æ¿",
                        Description: "ç”¨æ–¼ä»£ç¢¼é‡æ§‹å’Œå„ªåŒ–çš„æ¨¡æ¿",
                        Category:    CategoryMaintenance,
                        Prompt: `ä½œç‚ºä»£ç¢¼é‡æ§‹å°ˆå®¶ï¼Œè«‹å¹«åŠ©æˆ‘{{.query}}ã€‚

é‡æ§‹ç›®æ¨™ï¼š
- æé«˜ä»£ç¢¼å¯è®€æ€§å’Œå¯ç¶­è­·æ€§
- å„ªåŒ–æ€§èƒ½
- éµå¾ª SOLID åŸå‰‡
- æ”¹å–„ä»£ç¢¼çµæ§‹

{{if .focus_area}}
é‡é»é—œæ³¨ï¼š{{.focus_area}}
{{end}}

è«‹æä¾›é‡æ§‹å‰å¾Œçš„å°æ¯”å’Œè©³ç´°çš„æ”¹é€²å»ºè­°ã€‚`,
                        Variables: []string{"query", "focus_area"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateDocumentation,
                        Name:        "æ–‡æª”æ¨¡æ¿",
                        Description: "ç”¨æ–¼ç”Ÿæˆå’Œæ”¹é€²æ–‡æª”çš„æ¨¡æ¿",
                        Category:    CategoryDevelopment,
                        Prompt: `ä½œç‚ºæŠ€è¡“æ–‡æª”å°ˆå®¶ï¼Œè«‹å¹«åŠ©æˆ‘{{.query}}ã€‚

æ–‡æª”è¦æ±‚ï¼š
- æ¸…æ™°ç°¡æ½”çš„èªè¨€
- çµæ§‹åŒ–çš„å…§å®¹çµ„ç¹”
- åŒ…å«å¯¦éš›ä½¿ç”¨ç¤ºä¾‹
- é¢å‘{{.target_audience}}

{{if .doc_type}}
æ–‡æª”é¡å‹ï¼š{{.doc_type}}
{{end}}

è«‹ç¢ºä¿æ–‡æª”æ˜“æ–¼ç†è§£å’Œå¯¦ç”¨ã€‚`,
                        Variables: []string{"query", "target_audience", "doc_type"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplateTesting,
                        Name:        "æ¸¬è©¦æ¨¡æ¿",
                        Description: "ç”¨æ–¼ç·¨å¯«å’Œæ”¹é€²æ¸¬è©¦çš„æ¨¡æ¿",
                        Category:    CategoryDevelopment,
                        Prompt: `ä½œç‚ºæ¸¬è©¦å°ˆå®¶ï¼Œè«‹å¹«åŠ©æˆ‘{{.query}}ã€‚

æ¸¬è©¦è¦æ±‚ï¼š
- å®Œæ•´çš„æ¸¬è©¦è¦†è“‹
- åŒ…å«æ­£é¢å’Œè² é¢æ¸¬è©¦æ¡ˆä¾‹
- ä½¿ç”¨é©ç•¶çš„æ¸¬è©¦æ¡†æ¶
- æ¸…æ™°çš„æ¸¬è©¦æ„åœ–

{{if .test_type}}
æ¸¬è©¦é¡å‹ï¼š{{.test_type}}
{{end}}
{{if .coverage_target}}
è¦†è“‹ç‡ç›®æ¨™ï¼š{{.coverage_target}}
{{end}}

è«‹æä¾›è©³ç´°çš„æ¸¬è©¦ç­–ç•¥å’Œå¯¦ç¾ä»£ç¢¼ã€‚`,
                        Variables: []string{"query", "test_type", "coverage_target"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
                {
                        ID:          TemplatePerformance,
                        Name:        "æ€§èƒ½å„ªåŒ–æ¨¡æ¿",
                        Description: "ç”¨æ–¼æ€§èƒ½åˆ†æå’Œå„ªåŒ–çš„æ¨¡æ¿",
                        Category:    CategoryAnalysis,
                        Prompt: `ä½œç‚ºæ€§èƒ½å„ªåŒ–å°ˆå®¶ï¼Œè«‹å¹«åŠ©æˆ‘{{.query}}ã€‚

æ€§èƒ½åˆ†æé‡é»ï¼š
- è­˜åˆ¥æ€§èƒ½ç“¶é ¸
- æä¾›å…·é«”çš„å„ªåŒ–æ–¹æ¡ˆ
- è€ƒæ…®å…§å­˜å’Œ CPU ä½¿ç”¨
- æä¾›æ€§èƒ½æ¸¬è©¦å»ºè­°

{{if .performance_metric}}
é—œæ³¨æŒ‡æ¨™ï¼š{{.performance_metric}}
{{end}}
{{if .current_performance}}
ç•¶å‰æ€§èƒ½ï¼š{{.current_performance}}
{{end}}

è«‹æä¾›è©³ç´°çš„åˆ†æå’Œå„ªåŒ–å»ºè­°ã€‚`,
                        Variables: []string{"query", "performance_metric", "current_performance"},
                        CreatedAt: time.Now(),
                        IsBuiltIn: true,
                },
        }

        for _, tmpl := range builtInTemplates </span><span class="cov8" title="1">{
                tm.templates[tmpl.ID] = tmpl
        }</span>
}

// renderTemplate æ¸²æŸ“æ¨¡æ¿
func (tm *TemplateManager) renderTemplate(promptTemplate string, data map[string]string) (string, error) <span class="cov8" title="1">{
        // è¨ˆç®—æ¨¡æ¿å“ˆå¸Œä½œç‚ºç·©å­˜éµ
        cacheKey := tm.getTemplateHash(promptTemplate)

        // å˜—è©¦å¾ç·©å­˜ç²å–
        tm.mu.RLock()
        cachedTemplate, exists := tm.templateCache[cacheKey]
        tm.mu.RUnlock()

        var tmpl *template.Template
        var err error

        if exists </span><span class="cov0" title="0">{
                tmpl = cachedTemplate
        }</span> else<span class="cov8" title="1"> {
                // ç·¨è­¯æ–°æ¨¡æ¿
                tmpl, err = template.New("prompt").Parse(promptTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // æ·»åŠ åˆ°ç·©å­˜
                <span class="cov8" title="1">tm.mu.Lock()
                if len(tm.templateCache) &lt; tm.config.CacheSize </span><span class="cov8" title="1">{
                        tm.templateCache[cacheKey] = tmpl
                }</span>
                <span class="cov8" title="1">tm.mu.Unlock()</span>
        }

        <span class="cov8" title="1">var result strings.Builder
        if err := tmpl.Execute(&amp;result, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return result.String(), nil</span>
}

// validateTemplateVariables é©—è­‰æ¨¡æ¿è®Šé‡
func (tm *TemplateManager) validateTemplateVariables(tmpl *QueryTemplate) bool <span class="cov8" title="1">{
        // å¾æ¨¡æ¿ä¸­æå–è®Šé‡
        re := regexp.MustCompile(`\{\{\.(\w+)\}\}`)
        matches := re.FindAllStringSubmatch(tmpl.Prompt, -1)

        templateVars := make(map[string]bool)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        templateVars[match[1]] = true
                }</span>
        }

        // æª¢æŸ¥è²æ˜çš„è®Šé‡æ˜¯å¦éƒ½åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨
        <span class="cov8" title="1">declaredVars := make(map[string]bool)
        for _, variable := range tmpl.Variables </span><span class="cov8" title="1">{
                declaredVars[variable] = true
        }</span>

        // æ¨¡æ¿ä¸­çš„è®Šé‡éƒ½æ‡‰è©²åœ¨è²æ˜åˆ—è¡¨ä¸­
        <span class="cov8" title="1">for variable := range templateVars </span><span class="cov8" title="1">{
                if !declaredVars[variable] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// estimateTokens ä¼°ç®— token æ•¸é‡
func (tm *TemplateManager) estimateTokens(text string) int <span class="cov8" title="1">{
        // ç°¡å–®ä¼°ç®—ï¼šä¸­æ–‡å­—ç¬¦ 1 tokenï¼Œè‹±æ–‡å­—ç¬¦ 0.25 token
        tokens := 0
        for _, r := range text </span><span class="cov8" title="1">{
                if r &gt; 127 </span><span class="cov8" title="1">{ // é ASCII å­—ç¬¦ï¼ˆä¸»è¦æ˜¯ä¸­æ–‡ï¼‰
                        tokens++
                }</span> else<span class="cov8" title="1"> {
                        tokens += 1 // è‹±æ–‡å­—ç¬¦
                }</span>
        }
        <span class="cov8" title="1">return tokens / 3</span> // å¹³å‡åŒ–è™•ç†
}

// getTemplateHash ç”Ÿæˆæ¨¡æ¿å“ˆå¸Œå€¼ï¼ˆç°¡å–®å¯¦ç¾ï¼‰
func (tm *TemplateManager) getTemplateHash(template string) string <span class="cov8" title="1">{
        // ç°¡å–®çš„å“ˆå¸Œå¯¦ç¾ï¼šä½¿ç”¨å­—ç¬¦ä¸²é•·åº¦å’Œå‰å¾Œå­—ç¬¦
        length := len(template)
        if length == 0 </span><span class="cov0" title="0">{
                return "empty"
        }</span>

        <span class="cov8" title="1">first := template[0]
        last := template[length-1]

        return fmt.Sprintf("%d_%c_%c", length, first, last)</span>
}

// updateStats æ›´æ–°æ¨¡æ¿ä½¿ç”¨çµ±è¨ˆ
func (tm *TemplateManager) updateStats(templateID string, tokens int) <span class="cov8" title="1">{
        if !tm.config.EnableStats </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tm.mu.Lock()
        defer tm.mu.Unlock()

        stats, exists := tm.stats[templateID]
        if !exists </span><span class="cov8" title="1">{
                stats = &amp;TemplateStats{
                        TemplateID: templateID,
                }
                tm.stats[templateID] = stats
        }</span>

        <span class="cov8" title="1">stats.UsageCount++
        stats.LastUsed = time.Now()

        // æ›´æ–°å¹³å‡ token æ•¸
        if stats.UsageCount == 1 </span><span class="cov8" title="1">{
                stats.AvgTokens = float64(tokens)
        }</span> else<span class="cov0" title="0"> {
                stats.AvgTokens = (stats.AvgTokens*float64(stats.UsageCount-1) + float64(tokens)) / float64(stats.UsageCount)
        }</span>

        // å‡è¨­æ‰€æœ‰æ‡‰ç”¨éƒ½æˆåŠŸï¼ˆå¯¦éš›å¯¦ç¾ä¸­å¯èƒ½éœ€è¦è¿½è¹¤å¤±æ•—ï¼‰
        <span class="cov8" title="1">stats.SuccessRate = 1.0</span>
}

// GetStats ç²å–æ¨¡æ¿ä½¿ç”¨çµ±è¨ˆ
func (tm *TemplateManager) GetStats(templateID string) (*TemplateStats, bool) <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        stats, exists := tm.stats[templateID]
        return stats, exists
}</pre>
		
		<pre class="file" id="file3" style="display: none">package template

import (
        "sync"
        "text/template"
        "time"
)

// é å®šç¾©æ¨¡æ¿ ID
const (
        TemplateCoding        = "coding"
        TemplateDebug         = "debug"
        TemplateRefactor      = "refactor"
        TemplateDocumentation = "documentation"
        TemplateTesting       = "testing"
        TemplatePerformance   = "performance"
)

// æ¨¡æ¿åˆ†é¡
const (
        CategoryDevelopment = "development"
        CategoryMaintenance = "maintenance"
        CategoryAnalysis    = "analysis"
)

// QueryTemplate æŸ¥è©¢å„ªåŒ–æ¨¡æ¿
type QueryTemplate struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description"`
        Category    string            `json:"category"`
        Prompt      string            `json:"prompt"`       // æ¨¡æ¿æç¤ºè©ï¼Œæ”¯æŒè®Šé‡æ›¿æ›
        Variables   []string          `json:"variables"`    // æ¨¡æ¿ä¸­çš„è®Šé‡åˆ—è¡¨
        Metadata    map[string]string `json:"metadata"`     // é¡å¤–çš„å…ƒæ•¸æ“š
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        IsBuiltIn   bool              `json:"is_built_in"`  // æ˜¯å¦ç‚ºå…§å»ºæ¨¡æ¿
}

// ApplyResult æ¨¡æ¿æ‡‰ç”¨çµæœ
type ApplyResult struct {
        TemplateID      string            `json:"template_id"`
        OriginalQuery   string            `json:"original_query"`
        OptimizedPrompt string            `json:"optimized_prompt"`
        Context         map[string]string `json:"context"`
        AppliedAt       time.Time         `json:"applied_at"`
        TokensEstimate  int               `json:"tokens_estimate"`
}

// TemplateManager æ¨¡æ¿ç®¡ç†å™¨
type TemplateManager struct {
        templates    map[string]*QueryTemplate
        templateCache map[string]*template.Template // å·²ç·¨è­¯çš„æ¨¡æ¿ç·©å­˜
        stats        map[string]*TemplateStats     // ä½¿ç”¨çµ±è¨ˆ
        config       *TemplateConfig               // é…ç½®
        mu           sync.RWMutex
}

// TemplateStats æ¨¡æ¿ä½¿ç”¨çµ±è¨ˆ
type TemplateStats struct {
        TemplateID  string    `json:"template_id"`
        UsageCount  int       `json:"usage_count"`
        LastUsed    time.Time `json:"last_used"`
        AvgTokens   float64   `json:"avg_tokens"`
        SuccessRate float64   `json:"success_rate"`
}

// TemplateConfig æ¨¡æ¿é…ç½®
type TemplateConfig struct {
        EnableStats     bool `json:"enable_stats"`
        MaxCustom       int  `json:"max_custom"`        // æœ€å¤§è‡ªå®šç¾©æ¨¡æ¿æ•¸é‡
        CacheSize       int  `json:"cache_size"`        // ç·©å­˜å¤§å°
        ValidateStrict  bool `json:"validate_strict"`   // åš´æ ¼é©—è­‰æ¨¡å¼
}

// VariableInfo è®Šé‡ä¿¡æ¯
type VariableInfo struct {
        Name        string `json:"name"`
        Type        string `json:"type"`
        Required    bool   `json:"required"`
        Default     string `json:"default"`
        Description string `json:"description"`
}

// TemplateValidationError æ¨¡æ¿é©—è­‰éŒ¯èª¤
type TemplateValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

func (e *TemplateValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</pre>
		
		<pre class="file" id="file4" style="display: none">package terminal

import (
        "bufio"
        "context"
        "fmt"
        "os/exec"
        "sync"
        "time"
)

// TerminalManager å¯¦ç¾ Manager æ¥å£
type TerminalManager struct {
        terminals map[string]*Terminal
        mu        sync.RWMutex
        healthy   bool
}

// NewTerminalManager å‰µå»ºä¸€å€‹æ–°çš„çµ‚ç«¯ç®¡ç†å™¨
func NewTerminalManager() *TerminalManager <span class="cov8" title="1">{
        return &amp;TerminalManager{
                terminals: make(map[string]*Terminal),
                healthy:   true,
        }
}</span>

// StartTerminal å•Ÿå‹•æŒ‡å®šçš„çµ‚ç«¯
func (tm *TerminalManager) StartTerminal(config TerminalConfig) error <span class="cov8" title="1">{
        return tm.StartTerminalWithContext(context.Background(), config)
}</span>

// StartTerminalWithContext ä½¿ç”¨ä¸Šä¸‹æ–‡å•Ÿå‹•æŒ‡å®šçš„çµ‚ç«¯
func (tm *TerminalManager) StartTerminalWithContext(ctx context.Context, config TerminalConfig) error <span class="cov8" title="1">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        // æª¢æŸ¥çµ‚ç«¯æ˜¯å¦å·²å­˜åœ¨
        if _, exists := tm.terminals[config.Name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' already exists", config.Name)
        }</span>

        // å‰µå»ºæ–°çš„çµ‚ç«¯å¯¦ä¾‹
        <span class="cov8" title="1">terminal := &amp;Terminal{
                Name:     config.Name,
                Type:     config.Type,
                Status:   StatusStarting,
                LastUsed: time.Now().Unix(),
        }

        // å‰µå»ºå‘½ä»¤
        cmd := tm.createCommand(config)
        if cmd == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create command for terminal type %s", config.Type.String())
        }</span>

        <span class="cov8" title="1">terminal.Process = cmd

        // è¨­ç½®è¼¸å…¥è¼¸å‡ºç®¡é“
        if err := tm.setupPipes(terminal); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup pipes: %w", err)
        }</span>

        // åœ¨å¾Œå°å•Ÿå‹•é€²ç¨‹
        <span class="cov8" title="1">if err := tm.startProcess(ctx, terminal); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start process: %w", err)
        }</span>

        // æ·»åŠ åˆ°ç®¡ç†å™¨
        <span class="cov8" title="1">tm.terminals[config.Name] = terminal
        terminal.SetStatus(StatusRunning)

        return nil</span>
}

// StopTerminal åœæ­¢æŒ‡å®šåç¨±çš„çµ‚ç«¯
func (tm *TerminalManager) StopTerminal(name string) error <span class="cov8" title="1">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        terminal, exists := tm.terminals[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' not found", name)
        }</span>

        // è¨­ç½®åœæ­¢ç‹€æ…‹
        <span class="cov8" title="1">terminal.SetStatus(StatusStopping)

        // åœæ­¢é€²ç¨‹
        if terminal.Process != nil &amp;&amp; terminal.Process.Process != nil </span><span class="cov8" title="1">{
                if err := terminal.Process.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        terminal.SetStatus(StatusError)
                        return fmt.Errorf("failed to kill process: %w", err)
                }</span>
        }

        // ç­‰å¾…é€²ç¨‹çµæŸ
        <span class="cov8" title="1">if terminal.Process != nil </span><span class="cov8" title="1">{
                _ = terminal.Process.Wait()
        }</span>

        <span class="cov8" title="1">terminal.SetStatus(StatusStopped)
        return nil</span>
}

// SendCommand å‘æŒ‡å®šçµ‚ç«¯ç™¼é€å‘½ä»¤
func (tm *TerminalManager) SendCommand(name string, command string) error <span class="cov8" title="1">{
        tm.mu.RLock()
        terminal, exists := tm.terminals[name]
        tm.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' not found", name)
        }</span>

        <span class="cov8" title="1">if !terminal.IsRunning() </span><span class="cov8" title="1">{
                return fmt.Errorf("terminal '%s' is not running", name)
        }</span>

        // æ›´æ–°æœ€å¾Œä½¿ç”¨æ™‚é–“
        <span class="cov8" title="1">terminal.mu.Lock()
        terminal.LastUsed = time.Now().Unix()
        terminal.mu.Unlock()

        // ç™¼é€å‘½ä»¤
        if terminal.Stdin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("terminal '%s' stdin not available", name)
        }</span>

        <span class="cov8" title="1">if _, err := terminal.Stdin.WriteString(command + "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write command: %w", err)
        }</span>

        <span class="cov8" title="1">if err := terminal.Stdin.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush command: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetTerminal ç²å–æŒ‡å®šåç¨±çš„çµ‚ç«¯
func (tm *TerminalManager) GetTerminal(name string) (*Terminal, bool) <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        terminal, exists := tm.terminals[name]
        return terminal, exists
}</span>

// ListTerminals åˆ—å‡ºæ‰€æœ‰çµ‚ç«¯
func (tm *TerminalManager) ListTerminals() []*Terminal <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        terminals := make([]*Terminal, 0, len(tm.terminals))
        for _, terminal := range tm.terminals </span><span class="cov8" title="1">{
                terminals = append(terminals, terminal)
        }</span>

        <span class="cov8" title="1">return terminals</span>
}

// IsHealthy æª¢æŸ¥çµ‚ç«¯ç®¡ç†å™¨æ˜¯å¦å¥åº·
func (tm *TerminalManager) IsHealthy() bool <span class="cov8" title="1">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        return tm.healthy
}</span>

// createCommand å‰µå»ºå°æ‡‰é¡å‹çš„å‘½ä»¤
func (tm *TerminalManager) createCommand(config TerminalConfig) *exec.Cmd <span class="cov8" title="1">{
        var cmd *exec.Cmd

        switch config.Type </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                cmd = exec.Command("claude")</span>
        case TypeGeminiCLI:<span class="cov0" title="0">
                cmd = exec.Command("gemini")</span>
        case TypeCursor:<span class="cov0" title="0">
                cmd = exec.Command("cursor", "--cli")</span>
        case TypeAider:<span class="cov0" title="0">
                cmd = exec.Command("aider")</span>
        case TypeCustom:<span class="cov8" title="1">
                // å°æ–¼æ¸¬è©¦ï¼Œä½¿ç”¨ä¸€å€‹ç°¡å–®çš„å‘½ä»¤
                cmd = exec.Command("echo", "test")</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        // è¨­ç½®å·¥ä½œç›®éŒ„
        <span class="cov8" title="1">if config.WorkingDir != "" </span><span class="cov8" title="1">{
                cmd.Dir = config.WorkingDir
        }</span>

        // è¨­ç½®ç’°å¢ƒè®Šé‡
        <span class="cov8" title="1">if config.Environment != nil </span><span class="cov0" title="0">{
                for key, value := range config.Environment </span><span class="cov0" title="0">{
                        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // æ·»åŠ é¡å¤–åƒæ•¸
        <span class="cov8" title="1">if config.Args != nil </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, config.Args...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// setupPipes è¨­ç½®é€²ç¨‹çš„è¼¸å…¥è¼¸å‡ºç®¡é“
func (tm *TerminalManager) setupPipes(terminal *Terminal) error <span class="cov8" title="1">{
        // è¨­ç½®æ¨™æº–è¼¸å…¥ç®¡é“
        stdin, err := terminal.Process.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>
        <span class="cov8" title="1">terminal.Stdin = bufio.NewWriter(stdin)

        // è¨­ç½®æ¨™æº–è¼¸å‡ºç®¡é“
        stdout, err := terminal.Process.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>
        <span class="cov8" title="1">terminal.Stdout = bufio.NewScanner(stdout)

        return nil</span>
}

// startProcess åœ¨å¾Œå°å•Ÿå‹•é€²ç¨‹
func (tm *TerminalManager) startProcess(ctx context.Context, terminal *Terminal) error <span class="cov8" title="1">{
        // å‰µå»ºä¸€å€‹å¸¶å–æ¶ˆåŠŸèƒ½çš„ä¸Šä¸‹æ–‡
        processCtx, cancel := context.WithCancel(ctx)
        defer cancel()

        // è¨­ç½®è¶…æ™‚
        done := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                done &lt;- terminal.Process.Start()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        terminal.SetStatus(StatusError)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-processCtx.Done():<span class="cov0" title="0">
                terminal.SetStatus(StatusError)
                return processCtx.Err()</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"> // 5ç§’è¶…æ™‚
                terminal.SetStatus(StatusError)
                return fmt.Errorf("timeout starting process")</span>
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package terminal

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
)

// PlatformAdapter æä¾›è·¨å¹³å°çš„çµ‚ç«¯ç®¡ç†åŠŸèƒ½
type PlatformAdapter struct {
        os string
}

// NewPlatformAdapter å‰µå»ºæ–°çš„å¹³å°é©é…å™¨
func NewPlatformAdapter() *PlatformAdapter <span class="cov8" title="1">{
        return &amp;PlatformAdapter{
                os: runtime.GOOS,
        }
}</span>

// GetDefaultShell ç²å–ç•¶å‰å¹³å°çš„é»˜èª shell
func (pa *PlatformAdapter) GetDefaultShell() string <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows å„ªå…ˆä½¿ç”¨ PowerShellï¼Œå‚™é¸ cmd
                if pa.ValidateCommand("powershell.exe") </span><span class="cov8" title="1">{
                        return "powershell.exe"
                }</span>
                <span class="cov0" title="0">return "cmd.exe"</span>
        case "darwin", "linux":<span class="cov0" title="0">
                // Unix-like ç³»çµ±å„ªå…ˆä½¿ç”¨ bashï¼Œå‚™é¸ sh
                if pa.ValidateCommand("/bin/bash") </span><span class="cov0" title="0">{
                        return "/bin/bash"
                }</span>
                <span class="cov0" title="0">return "/bin/sh"</span>
        default:<span class="cov0" title="0">
                // å…¶ä»–ç³»çµ±ä½¿ç”¨é€šç”¨ shell
                return "/bin/sh"</span>
        }
}

// GetExecutablePath ç²å–å‘½ä»¤çš„å®Œæ•´å¯åŸ·è¡Œè·¯å¾‘
func (pa *PlatformAdapter) GetExecutablePath(command string) string <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows ç³»çµ±è™•ç†
                extensions := []string{"", ".exe", ".cmd", ".bat", ".com"}

                for _, ext := range extensions </span><span class="cov8" title="1">{
                        fullCommand := command + ext
                        if path, err := exec.LookPath(fullCommand); err == nil </span><span class="cov8" title="1">{
                                return path
                        }</span>
                }

                // å¦‚æœæ²’æ‰¾åˆ°ï¼Œè¿”å›å¸¶ .exe çš„ç‰ˆæœ¬
                <span class="cov8" title="1">return command + ".exe"</span>

        default:<span class="cov0" title="0">
                // Unix-like ç³»çµ±
                if path, err := exec.LookPath(command); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>

                // å¦‚æœæ²’æ‰¾åˆ°ï¼Œè¿”å›åŸå‘½ä»¤ï¼ˆå¯èƒ½åœ¨ PATH ä¸­ï¼‰
                <span class="cov0" title="0">return command</span>
        }
}

// CreateCommand å‰µå»ºé©åˆç•¶å‰å¹³å°çš„å‘½ä»¤
func (pa *PlatformAdapter) CreateCommand(config TerminalConfig) *exec.Cmd <span class="cov8" title="1">{
        var cmdPath string
        var args []string

        switch config.Type </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("claude")
                args = []string{cmdPath}</span>

        case TypeGeminiCLI:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("gemini")
                args = []string{cmdPath}</span>

        case TypeCursor:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("cursor")
                args = []string{cmdPath, "--cli"}</span>

        case TypeAider:<span class="cov8" title="1">
                cmdPath = pa.GetExecutablePath("aider")
                args = []string{cmdPath}</span>

        case TypeCustom:<span class="cov8" title="1">
                // å°æ–¼æ¸¬è©¦ï¼Œä½¿ç”¨å¹³å°é©ç•¶çš„æ¸¬è©¦å‘½ä»¤
                if pa.os == "windows" </span><span class="cov8" title="1">{
                        cmdPath = pa.GetExecutablePath("cmd")
                        args = []string{cmdPath, "/c", "echo", "test"}
                }</span> else<span class="cov0" title="0"> {
                        cmdPath = "/bin/echo"
                        args = []string{cmdPath, "test"}
                }</span>

        default:<span class="cov0" title="0">
                // é»˜èªä½¿ç”¨ shell
                cmdPath = pa.GetDefaultShell()
                args = []string{cmdPath}</span>
        }

        // å‰µå»ºå‘½ä»¤
        <span class="cov8" title="1">cmd := &amp;exec.Cmd{
                Path: cmdPath,
                Args: args,
        }

        // è¨­ç½®å·¥ä½œç›®éŒ„
        if config.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = config.WorkingDir
        }</span>

        // æ·»åŠ é¡å¤–åƒæ•¸
        <span class="cov8" title="1">if config.Args != nil </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, config.Args...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// SetupEnvironment è¨­ç½®å‘½ä»¤çš„ç’°å¢ƒè®Šé‡
func (pa *PlatformAdapter) SetupEnvironment(cmd *exec.Cmd, config TerminalConfig) <span class="cov8" title="1">{
        // ç²å–ç•¶å‰ç’°å¢ƒè®Šé‡
        env := os.Environ()

        // æ·»åŠ è‡ªå®šç¾©ç’°å¢ƒè®Šé‡
        if config.Environment != nil </span><span class="cov8" title="1">{
                for key, value := range config.Environment </span><span class="cov8" title="1">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // æ·»åŠ å¹³å°ç‰¹å®šçš„ç’°å¢ƒè®Šé‡
        <span class="cov8" title="1">switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows ç‰¹å®šç’°å¢ƒè¨­ç½®
                env = append(env, "AI_TERMINAL_PLATFORM=windows")

                // ç¢ºä¿ PATH åŒ…å«å¿…è¦çš„ç›®éŒ„
                pathEnvVar := pa.findPathVariable(env)
                if pathEnvVar == "" </span><span class="cov0" title="0">{
                        env = append(env, "PATH=C:\\Windows\\System32")
                }</span>

        default:<span class="cov0" title="0">
                // Unix-like ç³»çµ±ç‰¹å®šç’°å¢ƒè¨­ç½®
                env = append(env, "AI_TERMINAL_PLATFORM=unix")

                // ç¢ºä¿åŸºæœ¬çš„ PATH
                pathEnvVar := pa.findPathVariable(env)
                if pathEnvVar == "" </span><span class="cov0" title="0">{
                        env = append(env, "PATH=/usr/local/bin:/usr/bin:/bin")
                }</span>
        }

        <span class="cov8" title="1">cmd.Env = env</span>
}

// ValidateCommand æª¢æŸ¥å‘½ä»¤æ˜¯å¦å­˜åœ¨
func (pa *PlatformAdapter) ValidateCommand(command string) bool <span class="cov8" title="1">{
        // å¦‚æœæ˜¯çµ•å°è·¯å¾‘ï¼Œç›´æ¥æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if filepath.IsAbs(command) </span><span class="cov0" title="0">{
                _, err := os.Stat(command)
                return err == nil
        }</span>

        // ä½¿ç”¨ exec.LookPath åœ¨ PATH ä¸­æŸ¥æ‰¾
        <span class="cov8" title="1">_, err := exec.LookPath(command)
        return err == nil</span>
}

// GetProcessInfo ç²å–é€²ç¨‹ä¿¡æ¯
func (pa *PlatformAdapter) GetProcessInfo(pid int) *ProcessInfo <span class="cov8" title="1">{
        info := &amp;ProcessInfo{
                PID: pid,
        }

        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows ä½¿ç”¨ WMI æˆ– tasklist ç²å–é€²ç¨‹ä¿¡æ¯
                info.Command = pa.getWindowsProcessInfo(pid)
                info.ExecutablePath = pa.getWindowsExecutablePath(pid)
                info.Status = "running"</span>

        default:<span class="cov0" title="0">
                // Unix-like ç³»çµ±ä½¿ç”¨ /proc æˆ– ps
                info.Command = pa.getUnixProcessInfo(pid)
                info.CommandLine = pa.getUnixCommandLine(pid)
                info.Status = "running"</span>
        }

        <span class="cov8" title="1">return info</span>
}

// KillProcess è·¨å¹³å°æ®ºæ­»é€²ç¨‹
func (pa *PlatformAdapter) KillProcess(pid int) error <span class="cov8" title="1">{
        switch pa.os </span>{
        case "windows":<span class="cov8" title="1">
                // Windows ä½¿ç”¨ taskkill
                cmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", pid))
                return cmd.Run()</span>

        default:<span class="cov0" title="0">
                // Unix-like ç³»çµ±ä½¿ç”¨ kill
                cmd := exec.Command("kill", "-TERM", fmt.Sprintf("%d", pid))
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        // å¦‚æœ TERM å¤±æ•—ï¼Œå˜—è©¦ KILL
                        cmd = exec.Command("kill", "-KILL", fmt.Sprintf("%d", pid))
                        return cmd.Run()
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// è¼”åŠ©æ–¹æ³•ï¼šæŸ¥æ‰¾ PATH ç’°å¢ƒè®Šé‡
func (pa *PlatformAdapter) findPathVariable(env []string) string <span class="cov8" title="1">{
        for _, envVar := range env </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.ToUpper(envVar), "PATH=") </span><span class="cov8" title="1">{
                        return envVar
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Windows ç‰¹å®šçš„é€²ç¨‹ä¿¡æ¯ç²å–
func (pa *PlatformAdapter) getWindowsProcessInfo(pid int) string <span class="cov8" title="1">{
        // ç°¡åŒ–å¯¦ç¾ï¼šåœ¨å¯¦éš›é …ç›®ä¸­å¯èƒ½éœ€è¦ä½¿ç”¨ WMI
        cmd := exec.Command("tasklist", "/FI", fmt.Sprintf("PID eq %d", pid), "/FO", "CSV", "/NH")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        // è§£æ CSV è¼¸å‡ºç²å–é€²ç¨‹å
        <span class="cov8" title="1">lines := strings.Split(string(output), "\n")
        if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov8" title="1">{
                fields := strings.Split(lines[0], ",")
                if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                        // ç§»é™¤å¼•è™Ÿ
                        return strings.Trim(fields[0], "\"")
                }</span>
        }

        <span class="cov0" title="0">return "unknown"</span>
}

// Windows ç²å–å¯åŸ·è¡Œæ–‡ä»¶è·¯å¾‘
func (pa *PlatformAdapter) getWindowsExecutablePath(pid int) string <span class="cov8" title="1">{
        // ç°¡åŒ–å¯¦ç¾ï¼šå¯¦éš›é …ç›®ä¸­å¯èƒ½éœ€è¦ä½¿ç”¨ Windows API
        return "unknown"
}</span>

// Unix ç‰¹å®šçš„é€²ç¨‹ä¿¡æ¯ç²å–
func (pa *PlatformAdapter) getUnixProcessInfo(pid int) string <span class="cov0" title="0">{
        // å˜—è©¦å¾ /proc/PID/comm è®€å–é€²ç¨‹å
        commPath := fmt.Sprintf("/proc/%d/comm", pid)
        if data, err := os.ReadFile(commPath); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(string(data))
        }</span>

        // å‚™é¸ï¼šä½¿ç”¨ ps å‘½ä»¤
        <span class="cov0" title="0">cmd := exec.Command("ps", "-p", fmt.Sprintf("%d", pid), "-o", "comm=")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// Unix ç²å–å‘½ä»¤è¡Œ
func (pa *PlatformAdapter) getUnixCommandLine(pid int) string <span class="cov0" title="0">{
        // å˜—è©¦å¾ /proc/PID/cmdline è®€å–å‘½ä»¤è¡Œ
        cmdlinePath := fmt.Sprintf("/proc/%d/cmdline", pid)
        if data, err := os.ReadFile(cmdlinePath); err == nil </span><span class="cov0" title="0">{
                // /proc/PID/cmdline ä½¿ç”¨ null å­—ç¬¦åˆ†éš”åƒæ•¸
                cmdline := strings.ReplaceAll(string(data), "\x00", " ")
                return strings.TrimSpace(cmdline)
        }</span>

        // å‚™é¸ï¼šä½¿ç”¨ ps å‘½ä»¤
        <span class="cov0" title="0">cmd := exec.Command("ps", "-p", fmt.Sprintf("%d", pid), "-o", "args=")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// ProcessInfo è·¨å¹³å°é€²ç¨‹ä¿¡æ¯çµæ§‹
type ProcessInfo struct {
        PID            int    // é€²ç¨‹ ID
        Command        string // é€²ç¨‹å‘½ä»¤å
        CommandLine    string // å®Œæ•´å‘½ä»¤è¡Œ
        ExecutablePath string // å¯åŸ·è¡Œæ–‡ä»¶è·¯å¾‘
        Status         string // é€²ç¨‹ç‹€æ…‹
}</pre>
		
		<pre class="file" id="file6" style="display: none">package terminal

import (
        "bufio"
        "os/exec"
        "sync"
)

// TerminalType è¡¨ç¤ºæ”¯æ´çš„ AI çµ‚ç«¯é¡å‹
type TerminalType int

const (
        TypeClaudeCode TerminalType = iota // Claude Code CLI
        TypeGeminiCLI                      // Gemini CLI
        TypeCursor                         // Cursor CLI
        TypeAider                          // Aider CLI
        TypeCustom                         // è‡ªå®šç¾©çµ‚ç«¯
)

// String è¿”å›çµ‚ç«¯é¡å‹çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (t TerminalType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                return "claude"</span>
        case TypeGeminiCLI:<span class="cov8" title="1">
                return "gemini"</span>
        case TypeCursor:<span class="cov8" title="1">
                return "cursor"</span>
        case TypeAider:<span class="cov8" title="1">
                return "aider"</span>
        case TypeCustom:<span class="cov8" title="1">
                return "custom"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// CommandName è¿”å›çµ‚ç«¯é¡å‹å°æ‡‰çš„å‘½ä»¤å
func (t TerminalType) CommandName() string <span class="cov8" title="1">{
        switch t </span>{
        case TypeClaudeCode:<span class="cov8" title="1">
                return "claude"</span>
        case TypeGeminiCLI:<span class="cov8" title="1">
                return "gemini"</span>
        case TypeCursor:<span class="cov8" title="1">
                return "cursor"</span>
        case TypeAider:<span class="cov8" title="1">
                return "aider"</span>
        default:<span class="cov8" title="1">
                return "bash"</span>
        }
}

// TerminalStatus è¡¨ç¤ºçµ‚ç«¯ç‹€æ…‹
type TerminalStatus int

const (
        StatusStopped TerminalStatus = iota // å·²åœæ­¢
        StatusStarting                      // å•Ÿå‹•ä¸­
        StatusRunning                       // é‹è¡Œä¸­
        StatusStopping                      // åœæ­¢ä¸­
        StatusError                         // éŒ¯èª¤ç‹€æ…‹
)

// String è¿”å›çµ‚ç«¯ç‹€æ…‹çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (s TerminalStatus) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StatusStopped:<span class="cov8" title="1">
                return "stopped"</span>
        case StatusStarting:<span class="cov8" title="1">
                return "starting"</span>
        case StatusRunning:<span class="cov8" title="1">
                return "running"</span>
        case StatusStopping:<span class="cov8" title="1">
                return "stopping"</span>
        case StatusError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Terminal è¡¨ç¤ºä¸€å€‹ AI çµ‚ç«¯å¯¦ä¾‹
type Terminal struct {
        Name     string         // çµ‚ç«¯åç¨±
        Type     TerminalType   // çµ‚ç«¯é¡å‹
        Status   TerminalStatus // çµ‚ç«¯ç‹€æ…‹
        Process  *exec.Cmd      // åº•å±¤é€²ç¨‹
        Stdin    *bufio.Writer  // æ¨™æº–è¼¸å…¥å¯«å…¥å™¨
        Stdout   *bufio.Scanner // æ¨™æº–è¼¸å‡ºæƒæå™¨
        LastUsed int64          // æœ€å¾Œä½¿ç”¨æ™‚é–“æˆ³
        mu       sync.RWMutex   // ä¿è­·ä¸¦ç™¼è¨ªå•çš„é–
}

// GetStatus å®‰å…¨åœ°ç²å–çµ‚ç«¯ç‹€æ…‹
func (t *Terminal) GetStatus() TerminalStatus <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.Status
}</span>

// SetStatus å®‰å…¨åœ°è¨­ç½®çµ‚ç«¯ç‹€æ…‹
func (t *Terminal) SetStatus(status TerminalStatus) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.Status = status
}</span>

// IsRunning æª¢æŸ¥çµ‚ç«¯æ˜¯å¦æ­£åœ¨é‹è¡Œ
func (t *Terminal) IsRunning() bool <span class="cov8" title="1">{
        return t.GetStatus() == StatusRunning
}</span>

// TerminalConfig çµ‚ç«¯é…ç½®
type TerminalConfig struct {
        Type        TerminalType          // çµ‚ç«¯é¡å‹
        Name        string                // çµ‚ç«¯åç¨±
        WorkingDir  string                // å·¥ä½œç›®éŒ„
        Environment map[string]string     // ç’°å¢ƒè®Šé‡
        Args        []string              // é¡å¤–åƒæ•¸
}

// Manager ä»‹é¢å®šç¾©çµ‚ç«¯ç®¡ç†å™¨çš„è¡Œç‚º
type Manager interface {
        // StartTerminal å•Ÿå‹•æŒ‡å®šçš„çµ‚ç«¯
        StartTerminal(config TerminalConfig) error

        // StopTerminal åœæ­¢æŒ‡å®šåç¨±çš„çµ‚ç«¯
        StopTerminal(name string) error

        // SendCommand å‘æŒ‡å®šçµ‚ç«¯ç™¼é€å‘½ä»¤
        SendCommand(name string, command string) error

        // GetTerminal ç²å–æŒ‡å®šåç¨±çš„çµ‚ç«¯
        GetTerminal(name string) (*Terminal, bool)

        // ListTerminals åˆ—å‡ºæ‰€æœ‰çµ‚ç«¯
        ListTerminals() []*Terminal

        // IsHealthy æª¢æŸ¥çµ‚ç«¯ç®¡ç†å™¨æ˜¯å¦å¥åº·
        IsHealthy() bool
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
